CHYBY:

 * Pøi obnovì výchozích sloupcù (podle defsu) není obnoveno tøídìní atd.

   Je otázka, zda v¾dy chceme obnovit také tøídìní, seskupování atd, ale
   ka¾dopádnì by to jít mìlo, a» u¾ to budou dva rùzné pøíkazy, nebo bude jen
   jeden který obnoví v¹e a hotovo. 

 * Chyba v ukládání nastavení sloupeèkù.

   V databázi ISASu jsem se vy¹krtl ze skupiny isas_admin.
   Pøes nabídku "Spustit formuláø" jsem si spustil defs ZakazkaSet:NAAN a skryl
   jsem si první dva sloupeèky. 
   Vyskoèil jsem z ISASu a pøidal se do skupiny isas_admin.	
   Spustil jsem si ISAS, napsal heslo a ke konci ke¹ování defsù to spadlo.	
   Pomáhá jedinì update bv_users_cfg set saved_config = NULL;

 * Skrytí sloupce po pøedchozí inline editaci skonèí na SEGFAULT.

 * Aktualizace políèka `data-changed' ve stavové øádce.

   Po vlo¾ení záznamu je zobrazeno, ¾e data nejsou ok i ve formuláøi, ze
   kterého byla zmìna provedena.

 * ShowForm po vyvolání pøes Enter nemá fokus.

   Procházení záznamù v ShowFormu má taky nìjaké mouchy. Taky se neaktualizuje
   èíslo záznamu ve stavové øádce.  Pozor - úèetní deník fokus má, seznam
   bì¾ných bankovních úètù ne (Základní tabulky -> Banka úèty -> V¹echny úèty
   -> Bì¾ný úèet).  Podívat se na procházení PgUp/PgDn -- zdá se, ¾e je naopak.

 * Posun po zamítnutí mazání øádku.

   Po odpovìdi "Ne" na otázku na smazání záznamu je posunut aktivní záznam na
   dal¹í øádek.  Dìje se to ale jen nìkdy a teï nevíme kdy.
  
 * Vyhledávání nìkdy skoèí na záznam následující za hledaným.

   Popisovaný problém se bì¾nì neprojevuje.  Napøíklad v zakázkách pøi
   vyhledávání podle kódu zakázky v¹ak bylo toto chování hlá¹eno, ale po
   restartu aplikace ne¹lo zreprodukovat.

 * Závislosti runtime_filterù (a asi i editability) nefungují tranzitivnì.

   Tj. napø. kdy¾ je filter závislý na dopoèítávaném políèku, které je zmìnìno
   na základì zmìny jiného políèka, není filter pøepoèítán.  Lze to obejít
   uvedením závislosti na v¹ech políèkách, na kterých je závislé ono
   dopoèítávané políèko (a také se tak v defsech dìje), ale není to
   systematické (problémy s údr¾bou).

 * Zkopírovat obsah buòky nefunguje s èe¹tinou.

 * Chybné zobrazení záznamu z jiné tabulky pøi zapnutém filtrování.

   Pøi zobrazení záznamu z jiné tabulky (napø. pøes kontextové menu øádku) je
   zobrazen pøíslu¹ný formuláø a vyhledán záznam.  Pokud jsem v¹ak ji¾ tento
   formuláø mìl pøedtím otevøený a nad ním zapnutý filter, nemusí se hledaný
   záznam ve formuláøi nacházet.  To v¹ak není nijak indikováno a je zvýraznìn
   øádek, který pravdìpodobnì odpovídá poøadí záznamu v nevyfiltrované
   tabulce.  V takové situaci je tøeba ohlásit, ¾e záznam nebyl nalezen.

NOVÉ VLASTNOSTI:

1) U¾ivatelské rozhraní

 * Souèasný výbìr nìkolika øádkù v øádkovém formuláøi.

   Nad tìmito øádky by potom ¹lo napøíklad spustit nìjakou proceduru, apod.

 * Ulo¾ené filtrovací podmínky.

   K tomu bude nejprve tøeba nìjak zpøehlednit v¹e, co se týká práce s rùznými
   typy filtrovacích podmínek uplatnìných v rùzných formuláøích.

   Filtrovací podmínka by mìla být definovatelná jednak ve specifikaci a jednak
   by mìla jít ulo¾it u¾ivatelem definovaná (naklikaná) podmínka.

 * Oddìlit popup menu celého BrowseFormu a øádku (asi i buòky).
 
 * Zobrazení editovatelných/needitovatelných políèek v ShowFormu.
 
 * Vyvolat EditForm ze ShowFormu.

 * Roz¹íøit øádek po dobu inline editace víceøádkového textu.
 
 * Detailnìj¹í kontrola nad rozli¹ením práv pøi UPDATE/INSERT

   Pokud není na políèko právo UPDATE, zakázat jej i pøi INSERTU, ale umo¾nit
   nìkterá políèka explicitnì povolit (pouze pro INSERT).  Nebo také povolit
   úplnì v¹e, nehledì na práva pro UPDATE.

 * Automatický filter èíselníku pøi vyplnìní wildcard hodnoty.

   Pokud je vyplnìna hodnota obsahující hvìzdièku, automaticky zapnout filtr
   pøi vyvolání èíselníku.

 * Pravé tlaèítko nad prázdným BrowseFormem.

 * Filtr distinct hodnot (v kontextovém menu záhlaví sloupce).

 * Filtrovat aktuální hodnoty (v kontextovém menu buòky).

 * Pou¾ití externího PS prohlí¾eèe.

 * Správa pøístupových práv pøes databázi a formuláø, nikoly pøes specifikace.

 * Menu na pravé tlaèítko ve vstupních políèkách versus gtk menu.

 * Zarovnávání a atributy v InputFieldu.

 * Masky políèek.

 * Pøepoèítání závislých políèek pøi výbìru z ListField.

   V souèasné dobì se dìje jen pøi zmìnì hodnoty.  Chtìli bychom ale, aby k
   pøepoèítání do¹lo pøi ka¾dém dvojkliku (nebo výbìru pravým tlaèítkem).

 * Pro datumová políèka umo¾nit display ukazující odpovídající den v týdnu.


2) Specifikace

 * Zmìny týkající se standardních konfiguraèních voleb.

   V defsech v¹ech projektù:
    - zru¹it celý defs NastaveniUIUser.
    - v NastaveniUser pøidat sloupeèek `saved_config'.
    - v application.py pøidat podporu pro ukládání konfigurace do saved_config.
   
   V databázi v¹ech projektù:
    - zru¹it sloupeèky `export_directory' a `export_encoding'
    - zru¹it v¹e, co se týká bv_users_ui_cfg.
    - pøidat sloupeèek `saved_config' do bv_users_cfg.
   
 * Zmìny ohlednì u¾ivatelského pøizpùsobení sloupcù BrowseFromu.

   `width = 0' zakázat a v¹echna taková políèka vyøadit z layoutu (nejprve
   logovat jako deprecated).
   
   `column_width = 0' nijak speciálnì neo¹etøovat (stejnì je ¹íøka minimálnì
   taková, aby se ve¹el label)

   Nový atribut `disabled' zcela zemezí takový sloupec zobrazit.

   `columns' zùstává, jen je tøeba jej sestavovat nìjak algoritmicky, aby to
   bylo pro danou situaci pokud mo¾no pøehledné a snadno udr¾ovatelné...

 * Zjednodu¹ená definice pøíkazù a jejich argumentù.

   Pokud instanci pøíkazu zavoláme s libovolnými klíèovými argumenty, je nyní
   vrácena dvojice (COMMAND, ARGS).  Toho je nyní vyu¾ito jednak pøi
   rozbalování FORM_COMMAND_MENU a DEFAULT_KEYMAP v application.py a jednak
   konstruktoru MItem, který by argument `command' v pøípadì pøedání dvojice
   rozbalí.  Bylo by dobré oddìlené pøedávání `args' úplnì zakázat a v¹ude
   pøejít na nový zpùsob definice.
   
 * Zjednodu¹ení vytváøení handlerù popup menu aktivního øádku BrowseFormu.

   Definovat v pytis-extensions parametrizovatelné funkce pro vytváøení èasto
   pou¾ívaných pøíkazù, jako napø. otevírání souvisejícího formuláøe apod.

 * Automaticky doplnit 'codebook' pro fieldspec políèka s enumerátorem.

 * V tiskovém menu umo¾nit definovat separátor a klávesové zkratky.

 * Práva view na jednotlivé sloupce.

 * Formuláøový dialog.

 * Nápovìda (pro specifikaci a také zvlá¹» pro ka¾dé políèko).

 * Kontrola práv pøi volání funkcí jako dbupdatemany apod.

 * Zru¹it 'allow_codebook_insert'???

   Vlo¾ení nové hodnoty do èíselníku by mohlo být provádìno pøes pøíkaz z popup
   menu èíselníkového políèka (pøes pravé tlaèítko my¹i).  To by mohlo být
   povoleno pro v¹echny èíselníky a tlaèítko "+" ve formuláøi by tak bylo
   zbyteèné.
   

INTERNÍ ZÁLE®ITOSTI:

 * Mezivrstva pro práci s aktuálním selectem, kurzory apod.

   Je tøeba oddìlit ve¹kerý kód týkající se práce s aktuálním selectem,
   získáváním dat podle èísla øádkù (práce s kurzorem) a cachování øádkù, který
   je nyní pøedev¹ím v ListTable do speciální tøídy (nadstavba datového
   rozhraní).  Podobné vìci se dìlají i v netabulkových formuláøích a je tøeba
   je mít na jednom místì.

 * Instance Value na rozhraní InputField.

   InputField.get_value(), InputField.set_value() nech» pracují s instancemi
   Value, ne se stringy.  Také by bylo vhodné, kdyby políèko mìlo pøístup pøímo
   k PresentedRow.
   
 * Pøepracování stavového øádku.

   Pole definovaná aplikací (message, list-position, ...) by mìla být pøítomna
   automaticky.  Mìlo by být mo¾né zobrazit ikonu a tooltip.  Mìlo by být mo¾né
   definovat políèko sledující stav konfiguraèní volby (nebo i jiné hodnoty?).
   Je tøeba myslet také na obnovení stavu pøi pøepínání formuláøù
   (`Form.restore()').

 * Nepou¾ívat mx.DateTime, ale Pythonový modul datetime.
   
   
ÈI©TÌNÍ:

 * Zru¹it argument 'check' konstruktoru FieldSpec.

 * Zru¹it argument 'ignore_enumerators' tøídy DataSpec a metodu 'make'.

 * S groupingem pracovat jako s celým èíslem.

   Problém bude hlavnì ve defsech, kde bývá grouping èasto specifikován jako
   název sloupce.
   
 * Zru¹it pøenastavování argumentù v metodì 'Application.run_form'.

   Jde o o¹etøení zpìtné kompatibility pøi pou¾ití starých argumentù 'key' a
   'new'.  Ty je tøeba nejprve ve v¹ech projektech pøestat pou¾ívat.

 * Validace hodnot konfiguraèních voleb.

   Pro ka¾dou konfiguraèní volbu je nyní znám její datový typ, tak¾e by nebyl
   problém do metody `Option.set_value()' pøidat kontrolu, zda pøedaná hodnota
   skuteènì odpovídá deklarovanému typu volby.

 * Handlery pøíkazù.

   Pøíkazy jsou obsluhovány tak, ¾e vyvoláme on_command aplikace a ta je
   zodpovìdna za pøedání pøíkazu formuláøi, pokud to není její pøíkaz.
   Formuláø zase pøedává pøíkazy políèkùm.  To odpovídá pùvodnímu návrhu.  Nyní
   v¹ak máme CommandHandler a metodu get_command_handler_instance(), tak¾e
   bychom pøíkazy mohli pøedávat rovnou instanci, které pøíkaz nále¾í.

   Pozor, mo¾ná to také nìjak souvisí s metodou
   KeyHandler._maybe_invoke_command().

   Dále by bylo mo¾né vyhledat pøímo metodu obsluhující daný pøíkaz podle názvu
   a neprokousávat se tak sérií if/elif v on_command.  To by mohlo zùstat jako
   fallback handler, kdy¾ není nalezena metoda odpovídajícího názvu.

 * U¾ivatelské pøíkazy.
 
   Pøíkazy s handlerem by nemìly být vùbec pou¾ívány.  Namísto nich nech» je
   vyu¾íván pøíkaz COMMAND_CONTEXT_MENU_ACTION, kde se handler definuje jako
   souèást argumentù a ne jako argument konstruktoru Command.  U¾ivatel zkrátka
   nemá co vytváøet vlastní instance tøídy Command.

   Ve v¹ech aplikacích je tøeba u¾ivatelské pøíkazy (definované pomocí
   user_cmd()) nahradit s vyu¾itím pøíkazu ListForm.COMMAND_CONTEXT_MENU_ACTION
   a poté mù¾eme v ListForm zru¹it zpracování pøíkazù s handlerem a také tento
   argument konstruktoru tøídy `Command'.

   Nìkteré pøíkazy nepracují s aktuálním øádkem.  Pro ty bude tøeba definovat
   dal¹í specializovaný pøíkaz.  Pøedávání argumentù by mìlo být pro ka¾dý
   pøíkaz pevnì dané a ne, ¾e se argumenty handleru zji¹»ují pomocí inspect...
   To se zavedlo zejména kvùli pøíkazùm, které nepracují s aktuálním øádkem,
   tak¾e nepøebírají argument 'row' a nìkdy potøebují datový objekt.
