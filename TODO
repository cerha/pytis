CHYBY:

 * Rekurze pøi zji¹tìní pùvodní hodnoty políèka v computeru.

   Pokud se v computeru pokou¹ím zjistit pùvodní hodnotu políèka, dojde k
   rekurzi. To je nepøíjemné, proto¾e èasto se za nìjakých podmínek chci
   rozhodnout, ¾e hodntu nepøepoèítím -> tedy vrátím pùvodní.  Jiná mo¾nost by
   byla nìjak umo¾nit v rámci návratové hodnoty computeru indikovat, ¾e se nic
   mìnit nemá.

 * ShowForm po vyvolání pøes Enter nemá fokus.

   Procházení záznamù v ShowFormu má taky nìjaké mouchy. Taky se neaktualizuje
   èíslo záznamu ve stavové øádce.  Pozor - úèetní deník fokus má, seznam
   bì¾ných bankovních úètù ne (Základní tabulky -> Banka úèty -> V¹echny úèty
   -> Bì¾ný úèet).  Podívat se na procházení PgUp/PgDn -- zdá se, ¾e je naopak.

 * Posun po zamítnutí mazání øádku.

   Po odpovìdi "Ne" na otázku na smazání záznamu je posunut aktivní záznam na
   dal¹í øádek.  Dìje se to ale jen nìkdy a teï nevíme kdy.
  
 * Vyhledávání nìkdy skoèí na záznam následující za hledaným.

   Popisovaný problém se bì¾nì neprojevuje.  Napøíklad v zakázkách pøi
   vyhledávání podle kódu zakázky v¹ak bylo toto chování hlá¹eno, ale po
   restartu aplikace ne¹lo zreprodukovat.

 * Závislosti runtime_filterù (a asi i editability) nefungují tranzitivnì.

   Tj. napø. kdy¾ je filter závislý na dopoèítávaném políèku, které je zmìnìno
   na základì zmìny jiného políèka, není filter pøepoèítán.  Lze to obejít
   uvedením závislosti na v¹ech políèkách, na kterých je závislé ono
   dopoèítávané políèko (a také se tak v defsech dìje), ale není to
   systematické (problémy s údr¾bou).

 * Validace ve filtrovacím dialogu.

   Hodnoty jsou validovány (podle typu pøíslu¹ného sloupce) ve chvíli
   filtrace.  Pøi nevalidní hodnotì je zobrazena zpráva, ale filtraèní fialog
   je i pøesto uzavøen.  Patrnì by bylo lep¹í aby zùstal otevøen, dokud není
   zadána pou¾itelná hodnota.  Navíc by asi nemìly pøi validaci být brány v
   úvahu constrainty.

 * Zkopírovat obsah buòky nefunguje s èe¹tinou.

   
NOVÉ VLASTNOSTI:

1) U¾ivatelské rozhraní

 * Zobrazit informaci o do¹lé notifikaci zmìny dat ve stavové øádce.

 * U¾ivatelsky pøizpùsobitelné poøadí a poèet sloupcù libovolného BrowseFromu.
   
 * Ulo¾ené filtrovací podmínky.

   K tomu bude nejprve tøeba nìjak zpøehlednit v¹e, co se týká práce s rùznými
   typy filtrovacích podmínek uplatnìných v rùzných formuláøích.

   Filtrovací podmínka by mìla být definovatelná jednak ve specifikaci a jednak
   by mìla jít ulo¾it u¾ivatelem definovaná (naklikaná) podmínka.

 * Oddìlit popup menu celého BrowseFormu a øádku (asi i buòky).
 
 * Zobrazení editovatelných/needitovatelných políèek v ShowFormu.
 
 * Vyvolat EditForm ze ShowFormu.

 * Roz¹íøit øádek po dobu inline editace víceøádkového textu.
 
 * Detailnìj¹í kontrola nad rozli¹ením práv pøi UPDATE/INSERT

   Pokud není na políèko právo UPDATE, zakázat jej i pøi INSERTU, ale umo¾nit
   nìkterá políèka explicitnì povolit (pouze pro INSERT).  Nebo také povolit
   úplnì v¹e, nehledì na práva pro UPDATE.

 * Automatický filter èíselníku pøi vyplnìní wildcard hodnoty.

   Pokud je vyplnìna hodnota obsahující hvìzdièku, automaticky zapnout filtr
   pøi vyvolání èíselníku.

 * Pravé tlaèítko nad prázdným BrowseFormem.

 * Filtr distinct hodnot (v kontextovém menu záhlaví sloupce).

 * Filtrovat aktuální hodnoty (v kontextovém menu buòky).

 * Pou¾ití externího PS prohlí¾eèe.

 * Správa pøístupových práv pøes databázi a formuláø, nikoly pøes specifikace.

 * Menu na pravé tlaèítko ve vstupních políèkách versus gtk menu.

 * Zarovnávání a atributy v InputFieldu.


2) Specifikace

 * Práva na procedury.

   Tak, jako lze zjistit práva na spu¹tìní formuláøe, mìlo by jít zjistit práva
   na spu¹tìní procedury.  Bude v¹ak tøeba vytvoøit nìjaký zpùsob, jak práva
   definovat.
 
 * Nápovìda (pro specifikaci a také zvlá¹» pro ka¾dé políèko).

 * Zjednodu¹ení vytváøení handlerù popup menu aktivního øádku BrowseFormu.

   Definovat pøíslu¹né funkce v pytis-extensions.  Zejména jde o otevírání
   souvisejícího formuláøe.

 * Automaticky doplnit 'codebook' pro fieldspec políèka s enumerátorem.

 * Práva view na jednotlivé sloupce.

 * V tiskovém menu umo¾nit definovat separátor a klávesové zkratky.

 * Formuláøový dialog.

 * Kontrola práv pøi volání funkcí jako dbupdatemany apod.

 * Masky políèek.


INTERNÍ ZÁLE®ITOSTI:

 * Mezivrstva pro práci s aktuálním selectem, kurzory apod.

   Je tøeba oddìlit ve¹kerý kód týkající se práce s aktuálním selectem,
   získáváním dat podle èísla øádkù (práce s kurzorem) a cachování øádkù, který
   je nyní pøedev¹ím v ListTable do speciální tøídy (nadstavba datového
   rozhraní).  Podobné vìci se dìlají i v netabulkových formuláøích a je tøeba
   je mít na jednom místì.

 * Instance Value na rozhraní InputField.

   InputField.get_value(), InputField.set_value() nech» pracují s instancemi
   Value, ne se stringy.  Také by bylo vhodné, kdyby políèko mìlo pøístup pøímo
   k PresentedRow.
   
 * Pøepracování stavového øádku?
 

ÈI©TÌNÍ:

 * Zru¹it tøídu 'RefSpec' & spol.

   Kromì vlastního 'RefSpec' je tøeba zru¹it také argument 'references'
   konstruktoru FieldSpec a metodu 'PresentedRow.refvalue' (a v¹echna její
   pou¾ití v defsech).

 * Zru¹it argument 'check' konstruktoru FieldSpec.

 * Zru¹it argument 'insert_unknown_values' konstruktoru 'CodebookSpec'.

 * Zru¹it pou¾ití atributu 'key' tøídy 'Command'.

   Také stejnojmenný argument konstruktoru nesmí být nikde pou¾it.  Poté je
   mo¾né zru¹it také metodu 'Command.__setattr__()'.

 * Zru¹it argument 'ignore_enumerators' tøídy DataSpec a metodu 'make'.

 * Zru¹it `allow_codebook_insert'???

   Vlo¾ení nové hodnoty do èíselníku by mohlo být provádìno pøes pøíkaz z popup
   menu èíselníkového políèka (pøes pravé tlaèítko my¹i).  To by mohlo být
   povoleno pro v¹echny èíselníky a tlaèítko "+" ve formuláøi by tak bylo
   zbyteèné.

 * Handlery pøíkazù.

   Pøíkazy jsou obsluhovány tak, ¾e vyvoláme on_command aplikace a ta je
   zodpovìdna za pøedání pøíkazu formuláøi, pokud to není její pøíkaz.
   Formuláø zase pøedává pøíkazy políèkùm.  To odpovídá pùvodnímu návrhu.  Nyní
   v¹ak máme CommandHandler a metodu get_command_handler_instance(), tak¾e
   bychom pøíkazy mohli pøedávat rovnou instanci, které pøíkaz nále¾í.

   Pozor, mo¾ná to také nìjak souvisí s metodou
   KeyHandler._maybe_invoke_command().

   Dále by bylo mo¾né vyhledat pøímo metodu obsluhující daný pøíkaz podle názvu
   a neprokousávat se tak sérií if/elif v on_command.  To by mohlo zùstat jako
   fallback handler, kdy¾ není nalezena metoda odpovídajícího názvu.

   
