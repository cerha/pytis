# -*- coding: utf-8 -*-

# Prostředky pro definici a zpracování konfigurace běhu aplikace
# 
# Copyright (C) 2002-2013 Brailcom, o.p.s.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""Prostředky pro definici a zpracování konfigurace běhu aplikace.

Celá konfigurace je definována instancí třídy 'Configuration', dokumentace
v této třídě poví více.

"""

import getopt
import imp
import os
import stat
import string
import sys
import time

import util
# The translation domain is pytis-wx because it is only needed with wx applications.
_ = util.translations('pytis-wx')

from pytis.util import *


class _OrderedDefinitionClass(type):
    """A metaclass allowing us to find out the order of class definitions."""
    _class_counter = 0
    def __init__(cls, name, bases, dict):
        cls._class_definition_order = _OrderedDefinitionClass._class_counter
        _OrderedDefinitionClass._class_counter += 1


class Configuration(object):
    """Definition of configuration and its particular options."""

    class Option(object):
        """Specification of a configuration option (variable).

        Definicí potomka této třídy se jménem začínajícím prefixem '_Option_'
        jako vnitřní třídy třídy 'Configuration' je automaticky definována nová
        konfigurační volba aplikace.  Jméno volby je shodné s částí jména
        takové třídy následující za prefixem '_Option_', její popis je
        v docstringu třídy.  Ostatní vlastnosti volby jsou definovány metodami
        a/nebo konstantami dané třídy.  Konkrétní hodnota je pak udržována
        v její instanci.

        Docstring tříd nepodléhá obvyklým formátovacím pravidlům.  Měl by mít
        podobu, jež se dobře vyjímá v komentáři pythonového zdrojového souboru.

        Standardní konfigurační volby jsou uvedeny přímo zde.  Aplikace může ve
        svém definičním souboru definovat další, své vlastní, konfigurační
        volby použitím potomka třídy 'Configuration' a doplněním dalších
        vnitřních tříd v něm rozšířit dostupné konfigurační volby.

        Po zpracování konfiguračních voleb je zbývající, nezpracovaná, část
        příkazové řádky přiřazena do 'sys.argv'.

        """
        __metaclass__ = _OrderedDefinitionClass
        
        _DESCR = None
        """Stručný (jednořádkový) popis volby."""
        
        _DOC = None
        """Podrobnější dokumentace významu volby a přípustných hodnot."""
        
        _DEFAULT = None
        """Default value of the configuration option.

        See `default()' documentation for more information.

        """
        _DEFAULT_STRING = None
        """Výchozí hodnota konfigurační volby pro dump.

        Více viz. dokumentace metody `default_string()'."""

        _CMDLINE = False
        """Příznak, zda tato volba může být zadána také z příkazové řádky.

        Pravdivou hodnotou této konstanty definujeme, že daná volba."""
        
        _LONG_OPTION = None
        """Specifikace dlouhé volby příkazové řádky pro 'getopt'."""
        
        _ENVIRONMENT = ()
        """Specifikace jmen proměnných prostředí obsahujících hodnotu volby.

        Více viz. dokumentace metody `environment()'."""

        _VISIBLE = True
        """Specifikace viditelnosti volby.

        Více viz. dokumentace metody `visible()'."""

        _TYPE = None
        """Data type of the option value as 'pytis.data.Type' instance or None.

        See `_type()' documentation for more information.

        """

        def __init__(self, configuration):
            """Inicializuj instanci volby.

            Argumenty:

              configuration -- instance třídy 'Configuration', ve které je
                konfigurační volba přítomna
                
            """
            self._configuration = configuration
            self._value = self._undefined = object()
            self._changed = False
            self._type_ = self._type()
            assert self._DESCR is not None, \
                   "Option '%s' doesn't define the description string." % \
                   self.name()

        def _compute_init_value(self, configuration):
            value = self._undefined
            long_option = self.long_option()
            if long_option:
                if long_option[-1] == '=':
                    boolean = False
                    long_option = long_option[:-1]
                else:
                    boolean = True
                try:
                    values = configuration.command_line_options[long_option]
                    if boolean:
                        value = True
                    else:
                        value = values[0]
                except KeyError:
                    pass
            if value is self._undefined:
                for var in self.environment():
                    varval = os.getenv(var)
                    if varval is not None:
                        value = varval
                        break
            if value is self._undefined:
                value = self._value
            if value is self._undefined:
                value = self.default()
            return value

        def _type(self):
            """Return data type of the option value as 'pytis.data.Type' instance or None.

            'None' stands for unspecified type, allowing the value to be any
            Python object.  Otherwise the option values will need to be valid
            inner values of given type.
            
            Instead of overriding this method directly, it is recommended to
            use predefined classes 'StringOption', 'NumericOption' and
            'BooleanOption'.

            """
            return self._TYPE
        
        def name(self):
            return self.__class__.__name__[8:]
        
        def init_value(self, force=False):
            """Inicializuj hodnotu proměnné.

            Argumenty:

              force -- právě když je nepravdivé, inicializuj hodnotu jen tehdy,
                je-li ještě nedefinována

            """
            if force or self._value is self._undefined:
                value = self._compute_init_value(self._configuration)
                self._value = value

        def value(self):
            """Vrať aktuální hodnotu konfigurační volby."""
            # Hodnotu nenastavujeme hned v konstruktoru, protože v té době
            # ještě nemusí být inicializovány jiné volby, na kterých tato volba
            # případně závisí.
            if self._value is self._undefined:
                self.init_value()
            return self._value

        def set_value(self, value, initialization=False):
            """Nastav hodnotu konfigurační volby na 'value'."""
            if not initialization:
                self._changed = True
            self._value = value

        def changed(self):
            """Vrať pravdu, pokud hodnota volby byla změněna aplikací.

            Za změnu je považováno jakékoliv nastavení volby na jinou hodnotu, než
            jakou daná volba nabyla během inicializace (tj. při načítání voleb
            příkazové řádky a konfiguračního souboru).
            
            """ 
            return self._changed

        def reset(self):
            """Set option value to the initial default value."""
            self._value = self._undefined
            self._changed = False

        def long_option(self):
            """Vrať specifikaci dlouhé volby pro 'getopt' jako string.

            Specifikace může mít například podobu 'debug' nebo 'datadir='.
            Pokud konfigurační volba není spojena s žádnou volbou příkazové
            řádky, vrať 'None'.

            Specifikaci lze upravit předefinováním konstanty `_OPTION' v
            odvozené třídě.
            
            """
            if self._LONG_OPTION is not None:
                return self._LONG_OPTION
            elif self._CMDLINE:
                import pytis.data
                name = self.name().replace('_','-')
                if isinstance(self.type(), pytis.data.Boolean):
                    return name
                else:
                    return name + '='
            else:
                return None

        def environment(self):
            """Vrať tuple jmen proměnných prostředí obsahujících hodnotu volby.

            Jména proměnných jsou strings.  Proměnné prostředí jsou zkoumány
            v uvedeném pořadí a platná je první z nich, která je v prostředí
            přítomna (a to i když je třeba její hodnota prázdná).  Proměnné
            prostředí mají nižší prioritu než volba příkazové řádky nebo
            hodnota v konfiguračním souboru, avšak vyšší prioritu než hodnota
            vrácená metodou 'default'.

            Specifikaci lze upravit předefinováním konstanty `_ENVIRONMENT' v
            odvozené třídě.
            
            """
            return self._ENVIRONMENT

        def default(self):
            """Return the default value of the configuration option.
            
            The value returned by this method is used if the option value is
            not set explicitly.

            Option specification may define the default value by overriding the
            constant `_DEFAULT' in simple cases or by overriding this
            method if needed.

            """
            return self._DEFAULT
        
        def default_string(self):
            """Vrať výchozí hodnotu konfigurační volby pro dump.

            Hodnota je vrácena jako řetězec, který bude vložen do vzorového
            konfiguračního souboru.  Tuto metodu je užitečné předefinovat
            v případě, že výchozí hodnota volby vrácená metodou 'default()' je
            závislá na konkrétním prostředí a/nebo nevystihuje způsob svého
            získání.

            Specifikaci lze upravit předefinováním konstanty `_DEFAULT_STRING'
            v odvozené třídě, nebo ve složitějších případech předefinováním
            této metody.


            """

            if self._DEFAULT_STRING is not None:
                return self._DEFAULT_STRING
            else:
                import pprint
                return pprint.PrettyPrinter().pformat(self.default())

        def type(self):
            """Return data type of the option value as 'pytis.data.Type' instance or None."""
            return self._type_
        
        def visible(self):
            """Vrať příznak viditelnosti volby.

            Vrácená hodnota určuje, zda má být volba přítomna ve vzorovém
            konfiguračním souboru.

            Specifikaci lze upravit předefinováním konstanty `_VISIBLE'
            v odvozené třídě.

            """
            return self._VISIBLE

        def description(self):
            """Vrať stručný jednořádkový popis volby 'name' jako řetězec."""
            return self._DESCR
        
        def documentation(self):
            """Vrať podrobný popis volby 'name' jako řetězec nebo None.
        
            Řetězec tak může být víceřádkový a délka jednoho řádku může přesahovat 80 znaků.  Pokud
            podrobný popis není definován, může vrátit též None.
            
            """
            return self._DOC

    class StringOption(Option):
        """Třída pro volby řetězcového typu."""
        def _type(self):
            import pytis.data
            return pytis.data.String()

    class BooleanOption(Option):
        """Třída pro volby typu boolean."""
        def _type(self):
            import pytis.data
            return pytis.data.Boolean()

    class ColorOption(Option):
        """Třída pro volby typu barva."""
        _DOC = "Barva je reprezentována řetězcem '#RRGGBB'."
        def _type(self):
            import pytis.data
            return pytis.data.Color()

    class NumericOption(Option):
        """Třída pro volby celočíselného typu."""
        def _type(self):
            import pytis.data
            return pytis.data.Integer()

    class FileOption(StringOption):
        def _compute_init_value(self, *args, **kwargs):
            value = super(Configuration.FileOption, self).\
                    _compute_init_value(*args, **kwargs)
            if not os.path.isabs(value):
                value = os.path.join(os.getcwd(), value)
            return value

    class HiddenOption(Option):
        """Mix-in třída pro skryté volby."""
        _VISIBLE = False
        
    class CommandlineOption(Option):
        """Mix-in třída pro volby příkazové řádky."""
        _CMDLINE = True
        
    # Volba pro konfiguraci samu

    class _Option_config_file(StringOption, HiddenOption):
        _DESCR = _(u"Umístění konfiguračního souboru.")
        _LONG_OPTION = 'config='
        _ENVIRONMENT = ('PYTISCONFIG',)
        def default(self):
            for filename in ('./config.py', '/etc/pytis/config.py'):
                if os.access(filename, os.F_OK):
                    result = filename
                    break
            else:
                result = None
            return result

    class _Option_user_config_file(StringOption, HiddenOption):
        _DESCR = _(u"Umístění doplňujícího konfiguračního souboru uživatele.")
        _DOC = _(u"Tento soubor, pokud, existuje, je načítán navíc ke " +
                 u"standardní konfiguraci a v něm definované volby mají vyšší " +
                 u"prioritu než volby ve standardním konfiguračním souboru. " +
                 u"Užitečné převážně pro ladění.")
        def default(self):
            config_file = self._configuration.config_file
            if config_file:
                dir, file = os.path.split(config_file)
                user_config_file = os.path.join(dir, '_'+file)
                if os.path.exists(user_config_file):
                    result = user_config_file
                else:
                    result = None
            else:
                result = None 
            return result
        
    # Volby užitečné hlavně pro ladění

    class _Option_help(BooleanOption, CommandlineOption, HiddenOption):
        _DESCR = _(u"Volba odpovídající --help na příkazové řádce.")
        _DEFAULT = False
        
    class _Option_debug(BooleanOption, CommandlineOption):
        _DESCR = _(u"Příznak ladícího režimu.")
        _DOC = _(u"Je-li zapnut, aplikace může běžet s více kontrolami " +
                 u"a vypisovat spoustu informací, obvykle však za cenu svého " +
                 u"výrazného zpomalení.")
        _DEFAULT = False
        
    class _Option_debug_on_error(BooleanOption, CommandlineOption):
        _DESCR = _(u"Příznak vyvolání debuggeru při chybě.")
        _DOC = _(u"Dojde-li k odchycení neočekávané výjimky a tato volba je " +
                 u"zapnuta, je vyvolán interaktivní debugger.  Je-li zapnuta " +
                 u"volba 'debug', je implicitně zapnuta i tato volba.  Užitečné " +
                 u"pouze pro ladění.")
        
        def default(self):
            return self._configuration.debug

    class _Option_debug_memory(BooleanOption, CommandlineOption):
        _DESCR = _(u"Příznak výpisu ladících informací o paměti.")
        _DOC = _(u"Je-li zapnuta, aplikace vypisuje informativní hlášky " +
                 u"garbage collectoru a jiné údaje o paměti.")
        _DEFAULT = False

    class _Option_bug_report_address(StringOption):
        _DESCR = _(u"E-mailová adresa, na kterou mají být posílána oznámení o chybě.")
        _DEFAULT = ''

    class _Option_bug_report_subject(StringOption):
        _DESCR = _(u"Subject mailu oznámení o chybě aplikace.")
        _DEFAULT = 'Bug report'

    class _Option_profile(BooleanOption, CommandlineOption):
        _DESCR = _(u"Příznak profilování.")
        _DOC = _(u"Je-li zapnut, aplikace se spustí v profilovacím režimu " +
                 u"a ukládá informace o trvání jednotlivých volání do souboru. " +
                 u"Zapnutí této volby velmi výrazně zpomaluje běh aplikace.")
        _DEFAULT = False
        
    class _Option_test_run_interactive(BooleanOption, HiddenOption):
        _DESCR = _(u"Příznak určující, zda mají být spouštěny i interaktivní testy.")
        _DOC = _(u"Týká se pouze regresivního testování.")

    class _Option_custom_debug(HiddenOption):
        _DESCR = _(u"Zvláštní ladící funkce, napojená na příkaz 'COMMAND_CUSTOM_DEBUG'.")
        _DEFAULT = (lambda self: None)

    # Cesty a adresáře

    class _Option_search_modules(CommandlineOption):
        _DESCR = _(u"Names of python modules containing pytis specifications.")
        _DOC = _(u"Sequence of names of python modules which should be searched for pytis "
                 "specifications.  If empty, specification names must by fully qualified "
                 "identifiers of python classes.  If a list is given, the names may be relative "
                 "to one of the modules named in the list.")
        _DEFAULT = ()
        _DEFAULT_STRING = "()"

    class _Option_resolver(Option):
        _DESCR = _(u"Specification name resolver.")
        _DOC = _(u"Instance of 'pytis.util.Resolver' used globally to resolve specification names.")
        def default(self):
            return Resolver(search=self._configuration.search_modules)

    class _Option_help_dir(FileOption, CommandlineOption):
        _DESCR = _(u"Adresář obsahující soubory s nápovědou.")
        _DOC = _(u"Může být zadán absolutně i relativně vzhledem k aktuálnímu adresáři.")
        _ENVIRONMENT = ('PYTISHELPDIR',)
        _DEFAULT = './help'

    class _Option_print_spec_dir(FileOption):
        _DESCR = _(u"Adresář obsahující specifikace tiskových sestav.")
        _DOC = _(u"Může být zadán absolutně i relativně vzhledem k aktuálnímu adresáři.")
        _DEFAULT = './output'

    # TODO: Dočasně vráceno, dokud ve všech projektech nepřejdeme na nový
    # systém nápovědy.
    class _Option_doc_dir(FileOption, CommandlineOption):
        _DESCR = _(u"Adresář obsahující dokumentaci.")
        _DEFAULT = './docs'

    class _Option_icon_dir(FileOption):
        _DESCR = _(u"Adresář s obrázkovými soubory.")
        _DOC = _(u"Může být zadán absolutně i relativně vzhledem k aktuálnímu adresáři.")
        _DEFAULT = './icons'

    class _Option_tmp_dir(StringOption):
        _DESCR = _(u"Adresář pro dočasné pomocné soubory.")
        _DEFAULT_STRING = "'/tmp'"
        def default(self):
            dirs = ['/tmp', '/var/tmp', '/usr/tmp']
            tmpdir = os.getenv('TMPDIR')
            if tmpdir is not None:
                dirs = [tmpdir] + dirs
            for d in dirs:
                if os.access(d, os.W_OK):
                    result = d
                    break
            else:
                result = '.'
            return result

    class _Option_logo(FileOption, CommandlineOption):
        _DESCR = _(u"Cesta k souboru s logem.")
        _DOC = _(u"Může být zadán absolutně i relativně vzhledem k aktuálnímu adresáři.")
        _DEFAULT = './icons/logo.bmp'

    # Databáze
    
    class _Option_dbuser(StringOption, CommandlineOption):
        _DESCR = _(u"Database user login name.")
        _DEFAULT_STRING = 'getpass.getuser()'
        def default(self):
            import getpass
            return getpass.getuser()

    class _Option_dbpass(StringOption, CommandlineOption):
        _DESCR = _(u"Database login password.")
        _DEFAULT = None
        
    class _Option_dbname(StringOption, CommandlineOption):
        _DESCR = _(u"Database name.")
        _DEFAULT = None

    class _Option_dbhost(StringOption, CommandlineOption):
        _DESCR = _(u"Database host name.")
        _DEFAULT = None
    
    class _Option_dbport(NumericOption, CommandlineOption):
        _DESCR = _(u"Database port number.")
        _DEFAULT = None
    
    class _Option_dbsslm(StringOption, CommandlineOption):
        _DESCR = _(u"Database SSL mode (one of string constants supported by the DB system).")
        _DEFAULT = None

    class _Option_dbschemas(StringOption, CommandlineOption):
        _DESCR = _(u"List of database schemas to use in the order of their preference.")
        _DEFAULT = None        
    
    class _Option_dbconnections(HiddenOption):
        _DESCR = _(u"Alternative database connections")
        _DOC = ("The default database connection is normally defined by 'dbconnection'.  Certain "
                "applications, however, may require multiple database connections, which are "
                "configured using this option.  The value is a dictionary assigning a connection "
                "specification to each connection by name.  Connection names are defined by "
                "applications (each application should mention the names of used conections in "
                "its documentation).  The connection specification (the value assigned to a "
                "connection name) is a dictionary with keys 'dbname', 'dbhost', 'dbport', "
                "'dbuser', 'dbpass' and 'dbsslm'.  Only 'dbname' is mandatory.  Their meaning "
                "and default values are the same as for the configuration options of the same "
                "names specifying the properties of the default connection.")
        _DEFAULT = {}
        
    class _Option_dbconnection(HiddenOption):
        _DESCR = _(u"Database connection specification instance ('pytis.data.DBConnection').")
        _DOC = _(u"The instance is constructed from the above db* option by default.")
        def default(self):
            map = {'dbname': 'database',
                   'dbhost': 'host',
                   'dbport': 'port',
                   'dbuser': 'user',
                   'dbpass': 'password',
                   'dbsslm': 'sslmode'}
            def connection_options(items):
                # Transform configuration option names to DBConnection option names.
                return dict([(map[key], value) for key, value in items
                             if value is not None])
            cfg = self._configuration
            options = connection_options([(option, getattr(cfg, option))
                                          for option in map.keys() if hasattr(cfg, option)])
            alternatives = [(name, connection_options(opts.items()))
                            for name, opts in cfg.dbconnections.items()]
            schemas_string = cfg.dbschemas
            if schemas_string:
                schemas = [s.strip() for s in schemas_string.split(',')]
            else:
                schemas = None
            import pytis.data
            return pytis.data.DBConnection(alternatives=dict(alternatives),
                                           schemas=schemas,
                                           **options)

    class _Option_dblogtable(StringOption):
        _DESCR = _(u"Jméno tabulky, do které mají být logovány DML SQL příkazy.")
        _DEFAULT = ''

    class _Option_dblisten(BooleanOption):
        _DESCR = _(u"Flag určující, zda má být spouštěn dohlížeč změn dat.")
        _DEFAULT = True

    class _Option_max_pool_connections(NumericOption):
        _DESCR = _(u"Maximum number of database connections stored in a pool " +
                   u"for a single connection specification. " +
                   u"If None then there is no limit.")
        _DEFAULT = None

    class _Option_connection_limit(NumericOption):
        _DESCR = _(u"Maximum number of concurrently open database connections " +
                   u"for a single connection specification in a database pool. " +
                   u"If None then there is no limit.")
        _DEFAULT = None

    # Logovací volby

    class _Option_log_logger(Option):
        _DESCR = _(u"Specifikace logovací třídy.")
        _DOC = _(u"Trojice (CLASS, ARGS, KWARGS), kde CLASS je logovací třída a " +
                 u"ARGS, resp. KWARGS, jsou argumenty, resp. klíčované " +
                 u"argumenty, jejího konstruktoru.  Standardní dostupné třídy " +
                 u"jsou SyslogLogger a StreamLogger.  Více o nich lze nalézt " +
                 u"v jejich dokumentaci.")
        
        _DEFAULT_STRING = '(log.StreamLogger, (sys.stderr,), {})'
        def default(self):
            import log
            return (log.StreamLogger, (sys.stderr,), {})

    class _Option_log_exclude(Option):
        _DESCR = _(u"Seznam typů logovacích hlášek, které mají být odfiltrovány.")
        _DOC = _(u"V seznamu lze použít konstanty 'OPERATIONAL', 'ACTION', 'EVENT' a 'DEBUG'.")
        _DEFAULT_STRING = '[DEBUG]'
        def default(self):
            if self._configuration.debug:
                return []
            else:
                import log
                return [log.DEBUG]

    class _Option_log_one_line_preferred(BooleanOption):
        _DESCR = _(u"Určuje, zda je preferováno stručné nebo jednotné formátování.")
        _DOC = _(u"Je-li tato volba nastavena na pravdu, jsou krátká data " +
                 u"v logovacích hláškách doporučujících stručnost připojena " +
                 u"ihned za hlášku místo vypsání na samostatný řádek.")
        _DEFAULT = True

    class _Option_log_module_filter(StringOption):
        _DESCR = _(u"Prefix jména modulu, jehož debugovací hlášky jsou propuštěny.")
        _DOC = _(u"Debugovací logovací hlášky modulů s jiným prefixem jsou " +
                 u"odfiltrovány.  Není-li definováno, jsou propuštěny všechny " +
                 u"hlášky (nestanoví-li jiný filtr jinak).  Užitečné pouze pro " +
                 u"ladění.")
        _DEFAULT = ''
        _DEFAULT_STRING = "'pytis.data'"

    class _Option_log_class_filter(Option):
        _DESCR = _(u"Sekvence jmen tříd, jejichž debugovací hlášky jsou propuštěny.")
        _DOC = _(u"Debugovací logovací hlášky ostatních tříd jsou odfiltrovány. " +
                 u"Je-li 'None', jsou propuštěny všechny hlášky (nestanoví-li " +
                 u"jiný filtr jinak).  Užitečné pouze pro ladění.")
        _DEFAULT = None
        _DEFAULT_STRING = "('pytis.data.DBDefaultClass',)"
            
    # Externí programy

    class _Option_printing_command(StringOption):
        _DESCR = _(u"Shellový příkaz pro provedení tisku, včetně argumentů.")
        _DOC = _(u"Příkaz musí být schopen převzít tisková data ze standardního vstupu.")
        _DEFAULT = 'lpr'

    class _Option_postscript_viewer(StringOption):
        _DESCR = _(u"Shell command to be used for displaying print preview PDF files. "
                   u"It must take the name of the file to be displayed as its first argument. ")
        _DEFAULT = ''

    class _Option_sendmail_command(StringOption):
        # Používáno již jen v pytis-extensions...
        _DESCR = _(u"Shellový příkaz sendmail včetně celé cesty (DEPRECATED).")
        _DEFAULT = '/usr/lib/sendmail'
        
    class _Option_smtp_server(StringOption):
        _DESCR = _(u"Jméno serveru odchozí pošty.")
        _DEFAULT = 'localhost'
        
    # Komunikace s klientskými stanicemi
    
    class _Option_rpc_local_port(NumericOption):
        _DESCR = _(u"Lokální komunikační port pro naslouchání pytisovým aplikacím.")
        _DEFAULT = 17984
        
    class _Option_rpc_remote_port(NumericOption):
        _DESCR = _(u"Vzdálený komunikační port na klientských stanicích.")
        _DEFAULT = 17984
        
    class _Option_rpc_key_file(FileOption):
        _DESCR = _(u"Soubor s klíčem certifikátu pro komunikaci s klientskými stanicemi.")
        _DEFAULT = 'linux.key'
        
    class _Option_rpc_certificate_file(FileOption):
        _DESCR = _(u"Soubor s certifikátem pro komunikaci s klientskými stanicemi.")
        _DEFAULT = 'linux.crt'

    class _Option_rpc_communication_enabled(BooleanOption):
        _DESCR = _(u"Zapnutí/vypnutí komunikace s windowsovými klientskými stanicemi.")
        _DEFAULT = True

    class _Option_rpc_remote_view(BooleanOption):
        _DESCR = _(u"Flag určující, zda prohlížet tiskové soubory na klientské stanici.")
        _DEFAULT = True
        
    # Ostatní konfigurační volby

    class _Option_application_name(StringOption):
        _DESCR = _(u"Jméno aplikace.")
        _DOC = _(u"Jméno může být libovolné, používá se např. jako titulek " +
                 u"okna nebo při logování.  Od něho je také odvozeno jméno " +
                 u"výchozího souboru pro ukládání uživatelských změn v " +
                 u"konfiguraci (po vypuštění speciálních znaků a diakritiky)")
        _DEFAULT = 'Pytis'

    class _Option_date_time_format(StringOption):
        _DESCR = _(u"Formát společně uvedeného data a času.")
        _DOC = _(u"Řetězec ve tvaru vyžadovaném parametrem `format' " +
                 u"konstruktoru třídy 'pytis.data.DateTime'.")
        def default(self):
            import pytis.data
            return pytis.data.DateTime.DEFAULT_FORMAT

    class _Option_date_format(StringOption):
        _DESCR = _(u"Formát data.")
        _DOC = _(u"Řetězec ve tvaru vyžadovaném parametrem `format' " +
                 u"konstruktoru třídy 'pytis.data.Date'.")
        def default(self):
            import pytis.data
            return pytis.data.Date.DEFAULT_FORMAT

    class _Option_time_format(StringOption):
        _DESCR = _(u"Formát času.")
        _DOC = _(u"Řetězec ve tvaru vyžadovaném parametrem `format' " +
                 u"konstruktoru třídy 'pytis.data.Time'.")
        def default(self):
            import pytis.data
            return pytis.data.Time.DEFAULT_FORMAT

    class _Option_lc_numeric(StringOption):
        _DESCR = _(u"Numeric locale.")
        _DOC = _(u"Hodnota musí být string reprezentující locale pro " +
                 u"formátování číselných položek.")
        _DEFAULT = 'C'

    class _Option_export_directory(StringOption):
        _DESCR = _(u"Adresář pro export do CSV souborů.")
        _DOC = _(u"Hodnota udává cestu k adresáři, kde se budou ukládat textové " +
                 u"CSV soubory.")
        _DEFAULT = '/tmp'

    class _Option_export_encoding(StringOption):
        _DESCR = _(u"Kódování exportovaných dat.")
        _DOC = _(u"Hodnota musí být jedním z podporovaných kódování v Pythonu.")
        _DEFAULT = 'iso8859-2'

    class _Option_cache_size(NumericOption):
        _DESCR = _(u"Velikost cache pro řádky datového objektu.")
        _DOC = _(u"Velikost je celé číslo, které udává počet řádků cache.")
        _DEFAULT = 20000

    class _Option_initial_fetch_size(NumericOption):
        _DESCR = _(u"Počet řádků, které se přednačtou do cache při prvním " +
                   u"selectu z datového objektu.")
        _DEFAULT = 100

    class _Option_fetch_size(NumericOption):
        _DESCR = _(u"Počet řádků, které se přinačítají do cache při dalších " +
                   u"selectech z datového objektu.")
        _DEFAULT = 100

    class _Option_sender_address(StringOption):
        _DESCR = _(u"E-mailová adresa odesílatele použitá např. jako odchozí adresa bug-reportů " +
                   u" apod.")
        _DEFAULT = None

    class _Option_clipboard_primary_selection(BooleanOption):
        _DESCR = _(u"Flag určující, zda se má při exportu použít primary selection.")
        _DEFAULT = False

    class _Option_use_wx_clipboard(BooleanOption):
        _DESCR = _(u"Flag určující, zda se má pro kopírování obsahu buňky použít wxClipboard")
        _DEFAULT = True

    class _Option_form_statistics(BooleanOption):
        _DESCR = _(u"Flag určující, zda mají být do databáze ukládány statistické informace " +
                   u"o otevíraných formulářích.")
        _DEFAULT = False

    class _Option_http_proxy(StringOption):
        _DESCR = _(u"HTTP proxy URI used for integrated web browser and other http services.  "
                   u"Example: 'http://127.0.0.1:3129'")
        _DEFAULT = None

    class _Option_fallback_table_print(BooleanOption):
        _DESCR = _(u"Flag určující, zda se má při tisku vytisknout prostá tabulka formuláře, "
                   u"pokud není aplikovatelný žádný specifičtější tisk. "
                   u"Není-li nastaveno, nevytiskne se v takovém případě nic.")
        _DEFAULT = False

    class _Option_run_form_timeout(NumericOption):
        _DESCR = _(u"Počet sekund, po kterých se uživateli nabídne přerušení zdlouhavého "
                   u"otevírání formuláře.")
        _DEFAULT = 40

    class _Option_output_row_limit(NumericOption):
        _DESCR = _(u"Maximální počet řádků, pro který se v tiskových sestavách formátuje "
                   u"datová tabulka bez potvrzení uživatele.")
        _DEFAULT = 1000
        
    # Volby přizpůsobení uživatelského rozhraní
        
    class _Option_show_tooltips(BooleanOption):
        _DESCR = _(u"Zobrazovat bublinovou nápovědu.")
        _DEFAULT = True
        
    class _Option_stretch_tables(BooleanOption):
        _DESCR = _(u"Roztahovat sloupce tabulek, aby využily celou šířku okna.")
        _DEFAULT = True
        
    class _Option_show_splash(BooleanOption):
        _DESCR = _(u"Zobrazovat úvodní uvítací dialog.")
        _DEFAULT = True
        
    class _Option_auto_menu_accel(BooleanOption):
        _DESCR = _(u"Automaticky doplnit položky menu prefixy akcelerátorových kláves (změna " +
                   u"vyžaduje restart aplikace).")
        _DEFAULT = True
        
    class _Option_cache_spec_onstart(BooleanOption):
        _DESCR = _(u"Příznak cachování specifikací při startu aplikace.")
        _DEFAULT = True

    class _Option_startup_forms(StringOption, CommandlineOption):
        _DESCR = _(u"Seznam formulářů, které mají být otevřeny po spuštění aplikace.")
        _DEFAULT = None

    class _Option_row_edit_fg_color(ColorOption):
        _DESCR = _(u"Barva textu editovaného řádku tabulkového formuláře.")
        _DEFAULT = '#ffffff'

    class _Option_row_edit_bg_color(ColorOption):
        _DESCR = _(u"Barva pozadí editovaného řádku.")
        _DEFAULT = '#c80000'

    class _Option_cell_highlight_color(ColorOption):
        _DESCR = _(u"Barva zvýraznění aktivní buňky tabulkového formuláře.")
        _DEFAULT = '#ffa000'

    class _Option_row_highlight_color(ColorOption):
        _DESCR = _(u"Barva zvýraznění aktivního řádku tabulkového formuláře.")
        _DEFAULT = '#00a0ff'

    class _Option_row_highlight_edited_color(ColorOption):
        _DESCR = _(u"Barva zvýraznění aktivního řádku tabulkového formuláře během inline editace.")
        _DEFAULT = '#ff0000'

    class _Option_row_highlight_unfocused_color(ColorOption):
        _DESCR = _(u"Barva zvýraznění aktivního řádku neaktivního tabulkového formuláře.")
        _DEFAULT = '#808080'

    class _Option_row_highlight_width(NumericOption):
        _DESCR = _(u"Šířka rámečku zvýraznění aktivního řádku tabulkového formuláře v px.")
        _DEFAULT = 3
        def _type(self):
            import pytis.data
            return pytis.data.Integer(minimum=0, maximum=10)

    class _Option_grid_line_color(ColorOption):
        _DESCR = _(u"Barva mřížky tabulkového formuláře.")
        _DEFAULT = '#6482be'

    class _Option_grouping_background_downgrade(ColorOption):
        _DESCR = _(u"Ztmavení barvy skupiny při seskupování řádků.")
        _DOC = _(u"Protože barva pozadí řádků není vždy bílá, je tato hodnota " +
                 u"chápána jako relativní.  O kolik je zvolená barva tmavší " +
                 u"než bílá, o tolik bude výsledná barva skupiny tmavší, než " +
                 u"barva pozadí ostatních řádků.  Barva je reprezentována " +
                 u"řetězcem '#RRGGBB'.")
        _DEFAULT = '#eceef0'

    class _Option_field_disabled_color(ColorOption):
        _DESCR = _(u"Barva pozadí needitovatelného vstupního políčka.")
        _DEFAULT = '#d8d8d8'
        
    class _Option_field_denied_color(ColorOption):
        _DESCR = _(u"Pozadí políčka needitovatelného kvůli přístupovým právům.")
        _DEFAULT = '#e0e4f0'

    class _Option_field_hidden_color(ColorOption):
        _DESCR = _(u"Pozadí políčka se skrytou hodnotou.")
        _DEFAULT = '#404040'

    class _Option_field_invalid_color(ColorOption):
        _DESCR = _(u"Barva pozadí vstupního políčka pokud aktuální hodnota není validní.")
        _DEFAULT = '#ffffc0'
        
    class _Option_filter_color(ColorOption):
        _DESCR = _(u"Barva záhlaví tabulky při zapnutém filtrování.")
        _DEFAULT = '#82c882'

    # Metody

    def __init__(self):
        self._init_options()

    def add_command_line_options(self, command_line):
        """Nastav volby dle příkazové řádky.

        Argumenty:

          command_line -- volby příkazové řádky jako sekvence strings; typicky
            'sys.argv'

        """
        self._init_options(command_line=command_line)

    def _init_options(self, command_line=None):
        PREFIX = '_Option_'
        options = {}
        for k, v in self.__class__.__dict__.items():
            if starts_with(k, PREFIX):
                name = k[len(PREFIX):]
                options[name] = v(self)
        self.__dict__['_options'] = options
        if command_line is None:
            command_line_options = {}
        else:
            command_line_options = self._parse_command_line_options(command_line)
        self.__dict__['command_line_options'] = command_line_options
        for o in ('config_file', 'user_config_file'):
            if o in options:
                opt = options[o]
                opt.init_value()
                v = opt.value()
            else:
                v = None
            self.__dict__['_' + o] = v
        self._read_configuration()
        for o in options.values():
            o.init_value(force=True)

    def _parse_command_line_options(self, command_line):
        command_line_options = {}
        long_options = [o.long_option() for o in self._options.values()
                        if o.long_option() is not None]
        opts, args = getopt.getopt(command_line[1:], '', long_options)
        sys.argv[1:] = args
        for o, a in opts:
            try:
                arglist = command_line_options[o[2:]]
            except KeyError:
                arglist = []
                command_line_options[o[2:]] = arglist
            arglist.append(a)
        return command_line_options

    def _read_configuration(self):
        conffile = self._config_file
        if conffile is not None:
            self.__dict__['_config_mtime'] = self._read_configuration_file(conffile)
        uconffile = self._user_config_file
        if uconffile is not None:
            self.__dict__['_user_config_mtime'] = self._read_configuration_file(uconffile)

    def _read_configuration_file(self, filename=True):
        try:
            filetime = os.stat(filename)[stat.ST_MTIME]
        except:
            raise Exception(_(u"Unable to stat configuration file:"), filename)
        try:
            f = open(filename)
        except:
            raise Exception(_(u"Unable to open configuration file:"), filename)
        try:
            del sys.modules['_config']
        except:
            pass
        try:
            confmodule = imp.load_source('_config', filename, f)
        finally:
            f.close()
        options = self._options
        cloptions = self.command_line_options
        for o in dir(confmodule):
            if o in options:
                opt = options[o]
                if opt.long_option() not in cloptions:
                    value = confmodule.__dict__[o]
                    opt.set_value(value, initialization=False)
        for o in self._options.values():
            if not o.changed():
                o.reset()
        return filetime

    def read_configuration_file(self, filename):
        """Read options from given pytis configuration file.

        Previously set configuration values may get reset during that process.

        Arguments:

          filename -- name of the pytis configuration file, basestring
          
        """
        assert isinstance(filename, basestring), filename
        return self._read_configuration_file(filename)

    def __getattr__(self, name):
        """Return the current value of configuration option 'name'.

        'name' must be a string name of an existing configuration option.  'AttributeError' is
        raised if no such option exists.

        """
        if __debug__ and name not in ('config_file', 'user_config_file'):
            now = time.time()
            reread = False
            if self._config_file and now > self._config_mtime:
                t = os.stat(self._config_file)[stat.ST_MTIME]
                if t > self._config_mtime:
                    reread = True
            if not reread and self._user_config_file and now > self._user_config_mtime:
                ut = os.stat(self._user_config_file)[stat.ST_MTIME]
                if ut > self._user_config_mtime:
                    reread = True
            if reread:
                self._read_configuration()
        try:
            return self._options[name].value()
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        """Set the value of configuration option 'name'.

        'name' must be a string name of an existing configuration option.  'AttributeError' is
        raised if no such option exists.
        
        """
        if name == 'user_config_file':
            self.__dict__['_user_config_file'] = value
            self.__dict__['_user_config_mtime'] = 0
        if name in self.__dict__['_options']:
            self.__dict__['_options'][name].set_value(value)
        elif hasattr(self, name):
            self.__dict__[name] = value
        else:
            raise AttributeError(name)

    def merge(self, dict, override_cmdline=False):
        """Nastav aktuální konfiguraci z hodnot daného slovníku.

        Argumenty:
          dict -- slovník, ze kterého mají být převzaty nové hodnoty.
            Převezmou se pouze hodnoty klíčů, jejichž názvy odpovídají
            definovaným konfiguračním volbám a to pouze v případě, že jsou
            definovány (obsahují jinou hodnotu než None).  Ostatní budou
            ignorovány.
          override_cmdline -- implicitně nejsou přenastavovány hodnoty převzaté
            z příkazové řádky.  Pravdivá hodnota tohoto argumentu způsobí, že
            budou přenastaveny všechny nalezené konfigurační volby včetně těch
            z příkazového řádku.
            
        """
        options = self._options
        clopt = self.command_line_options
        for o in dict.keys():
            if o in options and dict[o] != None:
                opt = options[o]
                if override_cmdline or opt.long_option() not in clopt:
                    opt.set_value(dict[o])

    def dump_config_template(self, stream):
        """Write configuration file template to 'stream'.

        'stream' must be a stream opened for writing.

        """
        #stream.write('# -*- coding: utf-8 -*-\n\n')
        from textwrap import wrap
        for option in self.options(sort=True):
            if option.visible():
                stream.write('# %s\n' % option.description())
                doc = option.documentation()
                if doc:
                    for line in wrap(doc, 77):
                        stream.write('# %s\n' % string.strip(line))
                value = option.default_string()
                indent = ' ' * (len(option.name()) + 3)
                stream.write('#%s = %s\n\n' % (option.name(), value.replace("\n", "\n#"+indent)))

    def options(self, sort=False):
        """Return a tuple of all configuration options as 'Configuration.Option' instances.

        If 'sort' is true, the options will be returned in the order of their definition.

        """
        options = self._options.values()
        if sort:
            def _cmp(o1, o2):
                return cmp(o1._class_definition_order, o2._class_definition_order)
            options.sort(_cmp)
        return tuple(options)

    def option(self, name):
        """Return the 'Configuration.Option' instance for the option of given 'name'.

        'name' must be a string name of an existing configuration option.  'AttributeError' is
        raised if no such option exists.

        """
        try:
            return self._options[name]
        except KeyError:
            raise AttributeError(name)
