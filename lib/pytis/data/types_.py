# -*- coding: iso-8859-2 -*-

# Datové typy
#
# Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007 Brailcom, o.p.s.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""Práce s datovými typy, jejich hodnotami a vnìj¹í reprezentací.

Základní ideou modulu je, ¾e uvnitø programu v¾dy pracujeme s hodnotami
urèitého, námi definovaného, typu.  Z dùvodu datové abstrakce pøi práci s daty
nepou¾íváme pøímo standardní typy Pythonu a jeho knihoven, nýbr¾ na¹e vlastní
obálky okolo nich, které nám zajistí nezávislost vùèi konkrétní reprezentaci
hodnot daného typu v rùzných èástech programu (PostgreSQL, wxWindows, ...).
Kromì toho nám tyto typové obálky mohou také poskytovat nìkteré doplòující
funkce související s typy dat, jako je napøíklad validace vstupní hodnoty
daného typu reprezentované stringem a její pøevod na interní reprezentaci, se
kterou dále v programu pracujeme.

Základem modulu je abstraktní tøída 'Type', která je spoleèným základem v¹ech
typových tøíd.  Jejím podìdìním vznikají konkrétní typy nebo jejich spoleèné
specializovanìj¹í základy.  Hodnoty daných typù jsou pak reprezentovány
instancemi samostatné tøídy 'Value'.

"""

import math
import re
from cStringIO import StringIO

from mx import DateTime as DT

from pytis.data import *


class _MType(type):

    def __call__ (self, *args, **kwargs):
        return self.make(*args, **kwargs)
    
    
class Type(object):
    """Abstraktní tøída slou¾ící jako spoleèný základ v¹ech typù.

    Tuto tøídu musí povinnì dìdit v¹echny typové tøídy.

    Instance této tøídy jsou pova¾ovány za immutable, nesmí být po své
    inicializaci modifikovány a mohou být neomezenì sdíleny.
    
    """
    __metaclass__ = _MType
    
    class _TypeTable:

        def __init__(self):
            self._id_counter = Counter()
            self._init_args_to_id = {}
            self._id_to_init_args = {}
            self._init_args_to_type = {}

        def _key(self, class_, args, kwargs):
            return (class_.__module__, class_.__name__) + \
                   args + tuple(kwargs.items())

        def id_of_initargs(self, class_, args, kwargs):
            table = self._init_args_to_id
            key = self._key(class_, args, kwargs)
            if table.has_key(key):
                result = table[key]
            else:
                result = table[key] = self._id_counter.next()
                self._id_to_init_args[result] = \
                  class_.__module__, class_.__name__, args, kwargs
            return result

        def get(self, id):
            if type(id) != type(0):
                raise Exception('Invalid id type', id)
            return self._id_to_init_args.get(id)

        def get_instance(self, class_, *args, **kwargs):
            table = self._init_args_to_type
            key = self._key(class_, args, kwargs)
            if table.has_key(key):
                result = table[key]
            else:
                result = table[key] = class_.__new__(class_)
                assert isinstance(result, class_)
                result.__init__(*args, **kwargs)
                result._id = self.id_of_initargs(class_, args, kwargs)
            assert result is not None
            return result

    _type_table = _TypeTable()
    _remote_type_table = None
    _remote_type_table_cache = {}

    VM_NULL_VALUE = 'VM_NULL_VALUE'
    VM_INVALID_VALUE =  'VM_INVALID_VALUE'
    _VM_NULL_VALUE_MSG = _("Prázdná hodnota")
    _VM_INVALID_VALUE_MSG = _("Nesprávná hodnota")
    
    _SPECIAL_VALUES = ()
    
    _VALIDATION_CACHE_LIMIT = 1000

    def _make(class_, *args, **kwargs):
        result = Type._type_table.get_instance(class_, *args, **kwargs)
        assert result is not None
        return result
    _make = staticmethod(_make)

    def make(class_, *args, **kwargs):
        """Pouze pro úèely zpìtné kompatibility a pro metatøídu.

        V novém kódu nepou¾ívat.

        """
        return class_._make(class_, *args, **kwargs)
    make = classmethod(make)

    def __init__(self, not_null=False, enumerator=None, constraints=(),
                 validation_messages=None):
        """Inicializuj instanci.

        Argumenty:
        
          not_null -- pøíznak udávající, zda hodnoty tohoto typu smí být
            prázdné.  Za prázdnou hodnotu je pova¾ována hodnota None, nebo
            libovolná jiná hodnota na None mapovaná (viz. konstanta
            _SPECIAL_VALUES).  Pokud tento argument pravdivý, neprojde prázdná
            hodnota validací.
            
          enumerator -- specifikace enumerátoru, jako instance `Enumerator',
            nebo None.  Slou¾í k realizaci integritních omezení výètového
            typu.  Více viz dokumentace tøídy `Enumerator'.
            
          constraints -- sekvence validaèních funkcí slou¾ících k realizaci
            libovolných integritních omezení.  Ka¾dá z tìchto funkcí je funkcí
            jednoho argumentu, kterým je vnitøní hodnota typu.  Funkce pro tuto
            hodnotu musí vrátit buï 'None', je-li hodnota správná, nebo
            chybovou hlá¹ku jako string v opaèném pøípadì.
            
          validation_messages -- dictionary identifikátorù a validaèních
            hlá¹ek.  Klíèe jsou identifikátory validaèních hlá¹ek definované
            konstantami tøídy s názvy zaèínajícími prefixem 'VM_' a hodnoty
            jsou hlá¹ky coby øetìzce.  Hlá¹ky z tohoto argumentu, jsou-li pro
            daný identifikátor definovány, mají pøednost pøed implicitními
            hlá¹kami definovanými typem.


        """
        super(Type, self).__init__()
        assert isinstance(not_null, types.BooleanType)
        assert enumerator is None or isinstance(enumerator, Enumerator)
        assert isinstance(constraints, (types.ListType, types.TupleType))
        assert validation_messages is None or \
               isinstance(validation_messages, types.DictType) 
        self._not_null = not_null
        self._enumerator = enumerator
        self._constraints = xtuple(constraints)
        vm = [(getattr(self, attr), getattr(self, '_'+attr+'_MSG'))
              for attr in dir(self) if attr.startswith('VM_')]
        self._validation_messages = dict(vm)
        if validation_messages is not None:
            self._validation_messages.update(validation_messages)
        self._fetched = True
        # Cachujeme na úrovni instancí, proto¾e ty jsou stejnì sdílené, viz
        # `__new__'.
        self._validation_cache = cache = \
            LimitedCache(self._validating_provider,
                         limit=self._VALIDATION_CACHE_LIMIT)
        if isinstance(enumerator, MutableEnumerator):
            # TODO: Jak se to bude chovat po smrti instance typu?
            enumerator.add_hook_on_update(lambda : cache.reset())

    def type_table(class_):
        """Vra» tabulku typù jako instanci '_TypeTable'.

        Jediný úèel této metody je zpøístupnit tabulku typù pro vzdálené
        pøedávání typù ze serveru na klienta.  Pro jiné úèely by tabulka typù
        nemìla být pou¾ívána.

        """
        return Type._type_table
    type_table = classmethod(type_table)
    
    def __cmp__(self, other):
        """Vra» 0, právì kdy¾ 'self' a 'other' reprezentují tentý¾ typ."""
        if not sameclass(self, other):
            result = compare_objects(self, other)
        elif self._id == other._id:
            result = 0
        elif self._constraints == other._constraints \
                 and self._not_null == other._not_null \
                 and cmp(self._enumerator, other._enumerator) == 0:
            result = 0
        else:
            result = -1
            #TODO: Volání compare_objects zpùsobuje rekurzi.  Existuje nìjaký
            # pøípad, kdy by se instance mohly rovnat i pøes nesplnìní vý¹e
            # uvedených podmínek?
            #result = compare_objects(self, other)
        return result

    def __getstate__(self):
        assert self._id is not None, ('Improper type instance', self)
        return self._id
    
    def __setstate__(self, state):
        if type(state) != type(0):
            raise InvalidAccessError('Invalid type identifier', state)
        self._id = state
        self._fetched = False

    def __getattr__(self, name):
        if self._fetched:
            raise AttributeError(name)
        assert self._id is not None, ('Improper type instance', self)
        id = self._id
        cache = self._remote_type_table_cache
        if cache.has_key(id):
            t = cache[id]
            if t.__class__ != self.__class__:
                raise ('Incorrect type class', self, t.__class__,
                       self.__class__)
        else:
            remote_table = Type._remote_type_table
            if remote_table is None:
                import config
                server = config.server
                if server is None:
                    raise AttributeError(name)
                import pytis.remote, Pyro.core
                uri = 'PYROLOC://%s/%s' % (server, pytis.remote.NAME_TYPE_TABLE)
                remote_table = Type._remote_type_table = \
                               Pyro.core.getProxyForURI(uri)
            class_module, class_name_, args, kwargs = \
               remote_table.get(id)
            if class_module != self.__class__.__module__ or \
                   class_name_ != self.__class__.__name__:
                raise Exception('Invalid type class', id, class_module,
                                class_name_, self.__class__.__name__)
            t = self.__class__(*args, **kwargs)
            cache[id] = t
        self.__dict__.update(t.__dict__)
        self._id = id
        self._fetched = True
        try:
            return self.__dict__[name]
        except KeyError:
            raise AttributeError(name)

    def validate(self, object, strict=True, **kwargs):
        """Validate the 'object' and return a 'Value' instance and an error.

        Arguments:
        
          object -- an object to be converted to a value
          strict -- passing 'False' leads to a ``tolerant'' validation.  No
            constraints are checked and the method does its best to convert
            anything reasonable to a value.  It may be useful when the
            reason is not validation, but the conversion.
          kwargs -- type specific keyword arguments

        Returns: a pair (VALUE, ERROR).  VALUE is a 'Value' instance (for a
        valid 'object') or 'None' (for an invalid 'object').  ERROR is 'None'
        for a valid 'object' and a 'ValidationError' instance for an invalid
        'object'.

        Most types require the 'object' to be a string, most often representing
        user input or a value loaded from a file or process.  Certain more
        sophisticated types, however, may accept or require an 'object' of a
        different type.  All types should, if possible, accept a string and if
        not (eg. for excessive complications), they should accept an object,
        which may be simply constructed from data picked up from the user
        interface.  If the 'object' is not a string or another type explicitely
        allowed in the documentation of the corresponding type class, the
        behavior of this method is undefined.

        The 'kwargs' argument allows parametrized validation for particular
        types.  Each type may specify its set of options, which control the way
        how the user input is treated.

        Most types should validate an empty string to a 'Value' instance, which
        has 'None' as its value.

        Derived classes should not override this method.  They should override
        '_validate()' instead.
        
        """
        # Tato metoda je zároveò pou¾ívána i pro pøevod hodnot získaných
        # z databázového rozhraní.  To není úplnì ideální, ale je to zatím
        # postaèující a rozli¹ení tìchto dvou pou¾ití nestojí za komplikace
        # s tím spojené.  Pokud by bylo potøeba v budoucnu toto rozli¹it, lze
        # pøidat dal¹í metodu nebo argument.  Nyní je to èásteènì øe¹eno
        # argumentem 'strict'.
        try:
            key = (object, strict, tuple(kwargs.items()))
            result = self._validation_cache[key], None
        except ValidationError, e:
            result = None, e
        return result

    def _validating_provider(self, key):
        object, strict, kwargs = key[0], key[1], dict(key[2])
        special = rassoc(object, self._SPECIAL_VALUES)
        if special:
            value = Value(self, special[0])
        elif object is None:
            value = Value(self, None)
        else:
            value, error = apply(self._validate, (object,), kwargs)
            if error:
                raise error
        if strict:
            self._check_constraints(value.value())
        return value
    
    def _validate(self, object, **kwargs):
        return Value(self, None), None
    
    def wm_validate(self, object):
        """Zvaliduj objekt pro wildcard matching.

        Argumenty:

          object -- validovaný objekt, string

        Vrací: dvojici (VALUE, ERROR).  VALUE je instance tøídy 'WMValue'
        (je-li 'object' správný) nebo je 'None' (je-li 'object' nesprávný).
        Je-li 'object' správný, je ERROR 'None', v opaèném pøípadì je instancí
        tøídy 'ValidationError', která obsahuje popis chyby.

        Ne v¹echny typy musí tento druh validace podporovat.  Ty, které
        nepodporují, vrací dvojici (None, ERROR).

        """
        assert isinstance(object, types.StringTypes)
        return WMValue(self, object), None

    def _validation_error(self, id, **kwargs):
        message = self._validation_messages[id]
        if kwargs:
            message %= kwargs
        return ValidationError(message)
        
    def _check_constraints(self, value):
        if value is None:
            if self._not_null:
                raise self._validation_error(self.VM_NULL_VALUE)
            else:
                return True
        if self._enumerator is not None and not self._enumerator.check(value):
            raise self._validation_error(self.VM_INVALID_VALUE)
        for c in self._constraints:
            cresult = c(value)
            if cresult is not None:
                raise ValidationError(cresult)

    def not_null(self):
        """Vra» pravdu, pokud hodnoty tohoto typu smí být prázdné."""
        return self._not_null

    def enumerator(self):
        """Vra» enumerátor svázaný s tímto typem."""
        return self._enumerator
            
    def export(self, value, *args, **kwargs):
        """Vra» stringovou reprezentaci 'value' schopnou validace.

        'value' je hodnota vrácená metodou 'Value.value' z objektu vytvoøeného
        v metodì 'validate' na základì *string* parametru.  Pro objekty vzniklé
        z argumentu 'validate', který nebyl string, je chování této metody
        nedefinováno.  Výjimkou je hodnota 'None', pro kterou v¹echny typy,
        v jejich¾ dokumentaci není øeèeno jinak, vrací prázdný string.

        V této tøídì metoda vrací výsledek operátoru '``', pouze pro 'value'
        rovno 'None' vrací prázdný string.  Potomci tøídy nech» tuto metodu
        nepøedefinovávají, nebo» metoda mù¾e provádìt i rùzné doplòující akce;
        nech» potomci pøedefinovávají metodu `_export()'.

        """
        special = assoc(value, self._SPECIAL_VALUES)
        if special:
            return special[1]
        exported = apply(self._export, (value,)+args, kwargs)
        return exported

    def _export(self, value):
        return `value`

    def default_value(self):
        """Vra» implicitní hodnotu typu jako instanci 'Value'.

        Pokud taková hodnota neexistuje nebo nemá smysl, vra» 'None'.
        
        Vrácená hodnota mù¾e být vyu¾ita napøíklad v inicializaci nových
        záznamù.

        """
        return Value(self, None)
  

class Number(Type):
    """Abstraktní typová tøída, která je základem v¹ech numerických typù.

    Tøída víceménì nic nového nedefinuje, je urèena pouze k podìdìní v¹emi
    numerickými typy, aby tyto byly jako¾to èíselné snadno rozpoznatelné.

    """
    _SPECIAL_VALUES = Type._SPECIAL_VALUES + ((None, ''),)


class Big(Type):
    """Mixin class denoting types with big values.

    Instances of this type are sometimes handled in Pytis in a special way,
    e.g. they are not printed to the terminal log.
    
    """

class Large(Big):
    """Mixin class denoting types with really large values.

    Instances of this type may be handled in a special way not only inside
    Pytis, but possibly inside databases as well.

    """

class Limited(Type):
    """Mixin class for types with possibly limited maximal lenght.

    Maximal length of a value of this type can be limited by passing the
    `maxled' constructor argument.
    
    """

    VM_MAXLEN = 'VM_MAXLEN'
    _VM_MAXLEN_MSG = _("Pøekroèena maximální délka %(maxlen)s")

    def __init__(self, maxlen=None, **kwargs):
        """Initialize the instance.
        
        Arguments:
        
          maxlen -- maximal length of a value of this type as integer or
            'None'; 'None' denotes unlimited lenght.
             
        Other arguments are passed to the parent constructor.

        """
        self._maxlen = maxlen
        super(Limited, self).__init__(**kwargs)

    def __cmp__(self, other):
        """Return 0 if 'self' and 'other' are of the same class and maxlen."""
        result = super(Limited, self).__cmp__(other)
        if not result:
            result = cmp(self.maxlen(), other.maxlen())
        return result

    def maxlen(self):
        """Return the maximal lenght of the value as an integer or 'None'.

        'None' denotes unlimited lenght.
        
        """
        return self._maxlen

    def _format_maxlen(self):
        return str(self._maxlen)

    def _check_constraints(self, value):
        super(Limited, self)._check_constraints(value)
        self._check_maxlen(value)

    def _check_maxlen(self, value):
        if value is not None and self._maxlen is not None \
               and len(value) > self._maxlen:
            raise self._validation_error(self.VM_MAXLEN,
                                         maxlen=self._format_maxlen())

    
class Integer(Number):
    """Libovolný integer."""

    VM_NONINTEGER = 'VM_NONINTEGER'
    _VM_NONINTEGER_MSG = _("Není to celé èíslo")
    
    def _validate(self, string):
        """Pokus se pøevést 'string' na plain nebo long integer.
        
        Pokud je 'string' mo¾no pøevést na plain integer, je správný a vrácená
        instance tøídy 'Value' obsahuje odpovídající hodnotu jako plain
        integer.  V jiném pøípadì platí analogické pravidlo pro long integers.
        Pokud 'string' není mo¾no pøevést na plain ani long integer, 'string'
        není správný a je vrácena chyba.

        Metoda validuje v¹echny zápisy integers akceptované Pythonem, zejména
        tedy i long integers ve tvaru '1L'.
        
        """
        assert isinstance(string, types.StringTypes), ('Not a string', string)
        error = None
        try:
            value = int(string)
        except:
            # Dokumentace Pythonu 1.5.2 neøíká, ¾e by `int' mohlo metat metat
            # nìjakou výjimkou, ale evidentnì by mìlo, pokud `string' nelze
            # na obyèejný integer pøevést.
            try:
                value = long(string)
            except:
                # Podobnì jako `int' i `long' by mìlo v pøípadì nemo¾nosti
                # pøevodu metat výjimku.
                value = None
        if value is not None:
            result = Value(self, value), None
        else:
            result = None, self._validation_error(self.VM_NONINTEGER)
        return result


class Serial(Integer):
    """Integer s automaticky generovanými hodnotami.

    Typ oproti 'Integer' nezavádí ¾ádné nové rysy, jeho význam je èistì
    specifikaèní.  Napøíklad u¾ivatelské rozhraní tak získává informaci, ¾e
    není tøeba ani ¾ádoucí explicitnì nastavovat hodnoty sloupcù tohoto typu
    v øádku pøi vkládání nového záznamu.

    """
    pass


class Float(Number):
    """Èíslo v pohyblivé øádové èárce v rozsahu podporovaném Pythonem."""

    CEILING = 'CEILING'
    """Konstanta pro typ zaokrouhlení ve 'validate'."""
    FLOOR = 'FLOOR'
    """Konstanta pro typ zaokrouhlení ve 'validate'."""

    VM_INVALID_NUMBER = 'VM_INVALID_NUMBER'
    _VM_INVALID_NUMBER_MSG = _("Není to povolené èíslo")
    
    def __init__(self, precision=None, **kwargs):
        """Definuj typ reálného èísla.

        Argumenty:

          precision -- nezáporný integer udávající poèet èísel za desetinnou
            èárkou uvádìný pøi exportu, nebo 'None' (pak není pøesnost umìle
            omezena)

        Ostatní klíèové argumenty jsou shodné, jako v pøedkovi.
             
        """
        super(Float, self).__init__(**kwargs)
        assert precision is None or precision >= 0, \
               ('Invalid precision', precision)
        if precision is None:
            format = '%f'
        else:
            format = '%%.%df' % precision
        self._format_string = format
        self._precision = precision

    def precision(self):
        """Vra» pøesnost èísla zadanou v konstruktoru jako integer."""
        return self._precision
    
    def _validate(self, string, precision=None, rounding=None):
        """Pokus se pøevést 'string' na float.

        Pokud je 'string' mo¾no pøevést na float, je správný a vrácená instance
        tøídy 'Value' obsahuje odpovídající hodnotu jako plain integer.  Pokud
        'string' pøevést mo¾no není, 'string' není správný a je vrácena chyba.

        Metoda validuje v¹echny zápisy floats akceptované Pythonem.

        Argumenty:

          precision -- nezáporný integer udávající poèet èísel za desetinnou
            èárkou, na která má být zvalidované èíslo zaokrouhleno, nebo 'None'
            (pak není pøesnost umìle omezena)
          rounding -- specifikace zaokrouhlení pøi po¾adavku na omezenou
            pøesnost; 'None' znaèí standardní zaokrouhlení, konstanta 'CEILING'
            zaokrouhlení smìrem nahoru, konstanta 'FLOOR' zaokrouhlení smìrem
            dolù (pozor na záporná èísla, platí to pro nì také pøesnì takto!)
        
        """
        assert isinstance(string, types.StringTypes), ('Not a string', string)
        assert precision is None or \
               type(precision) == type(0) and precision >=0, \
               ('Invalid precision', precision)
        error = None
        try:
            import locale
            # TODO: Odporný hack, z nìjakého dùvodu následující
            # metoda bez toho nezafunguje
            locale.getlocale(locale.LC_NUMERIC)
            value = locale.atof(string)
        except:
            # Dokumentace Pythonu 1.5.2 neøíká, ¾e by `float' mohlo metat metat
            # nìjakou výjimkou, ale evidentnì by mìlo, pokud `string' nelze
            # na float pøevést.
            value = None
        if value is not None:
            if precision is not None:
                # Pozor na pøevody mezi binárními a dekadickými èísly!
                rvalue = round(value, precision)
                if rounding:
                    if rounding == self.CEILING:
                        if rvalue < value:
                            rvalue = rvalue + math.pow(10, -precision)
                    elif rounding == self.FLOOR:
                        if rvalue > value:
                            rvalue = rvalue - math.pow(10, -precision)
                    else:
                        raise ProgramError('Invalid rounding argument',
                                           rounding)
                value = rvalue
            result = Value(self, value), None
        else:
            result = None, self._validation_error(self.VM_INVALID_NUMBER)
        return result

    def _export(self, value, locale_format=True):
        if locale_format:
            import locale
            return unicode(locale.format(self._format_string, value, 1))
        else:
            return unicode(self._format_string % value)

        
class String(Limited):
    """Libovolný string.

    Lze také specifikovat, ¾e øetìzec mù¾e mít pouze omezenou délku, blí¾e viz
    metody '__init__' a 'maxlen'.

    """    

    _VM_MAXLEN_MSG = _("Øetìzec pøesahuje maximální délku %(maxlen)s")
    _SPECIAL_VALUES = Type._SPECIAL_VALUES + ((None, ''),)
    
    def _validate(self, string):
        """Vra» instanci tøídy 'Value' s hodnotou 'string'.

        Pokud byla v konstruktoru specifikována maximální délka, 'string' je
        správný právì tehdy, není-li del¹í ne¾ tato délka.
        
        """
        assert isinstance(string, types.StringTypes), ('Not a string', string)
        return Value(self, unicode(string)), None

    def _export(self, value):
        # Pozor, na triviální funkci této metody se spoléhá Value.__init__ --
        # pøi zmìnì zde je nutná zmìna i tam.
        assert isinstance(value, types.StringTypes), \
               ('Value not a string', value)
        return isinstance(value, unicode) and value or unicode(value)


class _RegexValidatedString(String):

    VM_FORMAT = 'VM_FORMAT'
    _VM_FORMAT_MSG = _("Neplatný formát.")
    
    def _validate(self, string, *args, **kwargs):
        sup = super(_RegexValidatedString, self)
        value, error = sup._validate(string, *args, **kwargs)
        if error is None and self._VALIDATION_REGEX.match(string) is None:
            value, error = None, self._validation_error(self.VM_FORMAT)
        return value, error

    
class Color(_RegexValidatedString):
    """Barva reprezentovaná øetìzcem '#RRGGBB'."""

    _VALIDATION_REGEX = re.compile('^\#[0-9a-fA-F]{3,3}([0-9a-fA-F]{3,3})?$')
    _VM_FORMAT_MSG = _("Formát barvy neodpovídá ('#RGB' nebo '#RRGGBB')")

    
class Identifier(_RegexValidatedString):
    """Identifikátor."""
    _VALIDATION_REGEX = re.compile('^[a-zA-Z][0-9a-zA-Z_-]*$')

    
class Inet(String):
    """IPv4 nebo IPv6 adresa."""

    VM_INET_FORMAT = 'VM_INET_FORMAT'
    VM_INET_MASK = 'VM_INET_MASK'
    VM_INET_ADDR = 'VM_INET_ADDR'
    _VM_INET_FORMAT_MSG = _("Chybný formát Inet adresy.")
    _VM_INET_MASK_MSG = _("Chybná maska Inet adresy: %(mask)s")
    _VM_INET_ADDR_MSG = _("Chybná hodnota Inet adresy %(addr)s")
    
    _INET4_FORMAT = re.compile('(\d{1,3}(\.\d{1,3}){0,3}([/]\d{1,2}){0,1})$')

    def _validate(self, string, *args, **kwargs):
        # TODO: Doplnit i validaci pro IPv6 formát
        if not self._INET4_FORMAT.match(string):
            raise self._validation_error(self.VM_INET_FORMAT)
        if string.find('/') != -1:
            addr, mask = string.split('/')
            if int(mask) > 32:
                raise self._validation_error(self.VM_INET_MASK, mask=mask)
        else:
            addr, mask = string, '32'
        numbers = addr.split('.')        
        for n in numbers:
            if n and int(n) > 255:
                raise self._validation_error(self.VM_INET_ADDR, addr=addr)
        for i in range(len(numbers), 4):
            numbers.append('0')
        value = '%s/%s' % ('.'.join(numbers), mask)
        return Value(self, unicode(value)), None


class Macaddr(String):
    """MAC adresa."""

    VM_MACADDR_FORMAT = 'VM_MACADDR_FORMAT'
    _VM_MACADDR_FORMAT_MSG = _("Chybný formát MAC adresy.")
    
    _MACADDR_FORMAT = re.compile('([0-9a-fA-F]{2}[-:]{0,1}){5}[0-9a-fA-F]{2}$')
    
    def _validate(self, string, *args, **kwargs):
        if not self._MACADDR_FORMAT.match(string):
            raise self._validation_error(self.VM_MACADDR_FORMAT)
        macaddr = string.replace(':','').replace('-','')
        value = ':'.join( [macaddr[x:x+2]
                            for x in range(0,len(macaddr),2)] )
        return Value(self, unicode(value)), None

    
class DateTime(Type):
    """Èasový okam¾ik reprezentovaný instancí tøídy 'DateTime.DateTime'.

    Tøída je schopna pracovat pouze s absolutním èasovým okam¾ikem.  Èas je
    navíc v¾dy uva¾ován v UTC, èasové zóny nejsou podporovány.  Datum je
    podporováno pouze od roku 1000 dále.

    Formát data a èasu je shodný pro import a export a je dán parametrem
    'format' metody '__init__()'.
    
    """
    VM_DT_FORMAT = 'VM_DT_FORMAT'
    VM_DT_VALUE = 'VM_DT_VALUE'
    VM_DT_AGE = 'VM_DT_AGE'
    _VM_DT_FORMAT_MSG = _("Chybný formát data nebo èasu")
    _VM_DT_VALUE_MSG = _("Chybné datum nebo èas")
    _VM_DT_AGE_MSG = _("Datum mimo povolený rozsah")
    
    _SPECIAL_VALUES = Type._SPECIAL_VALUES + ((None, ''),)

    DEFAULT_FORMAT = '%Y-%m-%d %H:%M:%S'
    """Implicitní formát data a èasu."""
    SQL_FORMAT = DEFAULT_FORMAT
    """Formát data a èasu pou¾ívaný standardnì SQL stroji."""
    CZECH_FORMAT = '%d.%m.%Y %H:%M:%S'
    """Èeský \"úèetnický\" formát data a èasu."""

    if __debug__:
        _dt_type = type(DT.DateTimeFrom('2001-01-01'))

    def __init__(self, format=None, mindate=None, maxdate=None, **kwargs):
        """Inicializuj instanci.

        Argumenty:

          format -- specifikace vstupního i výstupního formátu data a/nebo
            èasu, v podobì akceptované funkcí 'time.strftime()'; mù¾e být té¾
            'None', v kterém¾to pøípadì se pou¾ije konfiguraèní volba
            'config.date_time_format'.  Tøída obsahuje pøeddefinované konstanty
            '*_FORMAT', které lze vyu¾ít jako hodnotu tohoto parametru.
          mindate. maxdate -- omezení validity èasu

        """
        assert mindate is None or isinstance(mindate, types.StringTypes)
        assert maxdate is None or isinstance(maxdate, types.StringTypes)
        if format is None:
            import config
            format = config.date_time_format
        self._format = format
        self._mindate = mindate
        self._maxdate = maxdate
        self._check_matcher = {}
        if mindate:
            try:
                self._mindate = DT.strptime(mindate, self.SQL_FORMAT)
            except:
                raise ProgramError('Bad value for mindate', mindate, self.SQL_FORMAT)
        if maxdate:
            try:
                self._maxdate = DT.strptime(maxdate, self.SQL_FORMAT)
            except:
                raise ProgramError('Bad value for maxdate', maxdate)                
        super(DateTime, self).__init__(**kwargs)
        
    def _check_format(self, format, string):
        try:
            matcher = self._check_matcher[format]
        except KeyError:
            special = {'%Y': r'\d\d\d\d', ' ': '\s+', '%p': '[AP]M'}
            def subst(match):
                m = match.group(1)
                try:
                    return special[m]
                except KeyError:
                    return m.startswith('%') and '\d?\d' or re.escape(m)
            regexp = re.sub('(\%[a-zA-Z]|.|\s+)', subst, format)
            self._check_matcher[format] = matcher = re.compile(regexp)
        return matcher.match(string)
        
    def _validate(self, string, format=None, local=True):
        """Stejné jako v pøedkovi a¾ na klíèované argumenty.

        Argumenty:

          string -- stejné jako v pøedkovi
          format -- po¾adovaný formát hodnoty 'string', ve tvaru po¾adovaném
            metodou '__init__()'
          local -- pravdivé právì kdy¾ zadaná hodnota je v lokálním èase;
            v opaèném pøípadì je v UTC
          
        """
        assert isinstance(string, types.StringTypes)
        if format is None:
            format = self._format
        # Vyu¾ití `strptime' je nejjednodu¹¹í øe¹ení.  GNU `strptime' je
        # dostateènì tolerantní vùèi nadbyteèným mezerám atd., tak¾e by jeho
        # pou¾itím nemìl vzniknout problém, pokud nehodláme software provozovat
        # na ne-GNU systémech, které `strptime' øádnì nepodporují.  Musíme
        # ov¹em oøezat mezery zprava, proto¾e v mx.DateTime vadí, je tam nìjaká
        # chyba, standardní `time.strptime' funguje.
        string = string.strip()
        dt = None
        try:
            if not self._check_format(format, string):
                raise ValidationError(self.VM_DT_FORMAT)
            dt = DT.strptime(string, format)
            if local:
                dt = dt.gmtime()
            if (self._mindate and dt < self._mindate) or \
                   (self._maxdate and dt > self._maxdate):
                result = None, self._validation_error(self.VM_DT_AGE)
            else:    
                result = Value(self, dt), None
        except Exception, e:
            result = None, self._validation_error(self.VM_DT_FORMAT)
        # TODO: zjistit, proè zde bylo udìláno toto omezení
        # Pro správnou funkènost tøídy Time je ale tøeba ho zru¹it
        #if dt is not None and dt.year < 1000:
        #    result = None, self._validation_error(self.VM_DT_AGE)
        return result
    
    def _export(self, value, local=True):
        """Stejné jako v pøedkovi a¾ na klíèované argumenty.

        Argumenty:

          local -- pravdivé právì kdy¾ zadaná hodnota je v lokálním èase;
            v opaèném pøípadì je v UTC
          
        """
        assert type(value) == self._dt_type, 'Value is not DateTime'
        if local:
            value = value.localtime()
        return value.strftime(self._format)

    def now(class_, **kwargs):
        """Vra» instanci 'Value' tohoto typu odpovídající aktuálnímu okam¾iku.

        Argumenty:

          kwargs -- argumenty pøedané konstruktoru tøídy typu
          
        """
        type = class_(**kwargs)
        return Value(type, DT.now())
    now = classmethod(now)


class Date(DateTime):
    """Datum bez èasového údaje."""

    DEFAULT_FORMAT = '%Y-%m-%d'
    """Implicitní formát data."""
    SQL_FORMAT = DEFAULT_FORMAT
    """Formát data pou¾ívaný standardnì SQL stroji."""
    CZECH_FORMAT = '%d.%m.%Y'
    """Èeský \"úèetnický\" formát data."""

    def __init__(self, format=None, **kwargs):
        """Inicializuj instanci.

        Argumenty:

          format -- specifikace vstupního i výstupního formátu data, v podobì
            akceptované funkcí 'time.strftime()'; mù¾e být té¾ 'None',
            v kterém¾to pøípadì se pou¾ije konfiguraèní volba
            'config.date_format'.  Tøída obsahuje pøeddefinované konstanty
            '*_FORMAT', které lze vyu¾ít jako hodnotu tohoto parametru.

        """
        if format is None:
            import config
            format = config.date_format
        super(Date, self).__init__(format=format, **kwargs)

    def _validate(self, *args, **kwargs):
        kwargs['local'] = False
        return super(Date, self)._validate(*args, **kwargs)
        
    def _export(self, *args, **kwargs):
        kwargs['local'] = False
        return super(Date, self)._export(*args, **kwargs)


class Time(DateTime):
    """Èas bez datumového údaje."""

    DEFAULT_FORMAT = '%H:%M:%S'
    """Implicitní formát èasu."""
    SQL_FORMAT = DEFAULT_FORMAT
    """Formát èasu pou¾ívaný standardnì SQL stroji."""
    SHORT_FORMAT = '%H:%M'
    """Formát èasu bez zobrazení sekund."""

    def __init__(self, format=None, **kwargs):
        """Inicializuj instanci.

        Argumenty:

          format -- specifikace vstupního i výstupního formátu èasu, v podobì
            akceptované funkcí 'time.strftime()'; mù¾e být té¾ 'None',
            v kterém¾to pøípadì se pou¾ije konfiguraèní volba
            'config.time_format'.  Tøída obsahuje pøeddefinované konstanty
            '*_FORMAT', které lze vyu¾ít jako hodnotu tohoto parametru.

        """
        if format is None:
            import config
            format = config.time_format
        super(Time, self).__init__(format=format, **kwargs)

    def _validate(self, *args, **kwargs):
        kwargs['local'] = False
        return super(Time, self)._validate(*args, **kwargs)
        
    def _export(self, *args, **kwargs):
        kwargs['local'] = False
        return super(Time, self)._export(*args, **kwargs)


class Boolean(Type):
    """Jednoduchý výètový typ implementující hodnoty \"pravda\" a \"nepravda\".
    
    Za pravdu je pova¾ován string 'T', za nepravdu string 'F'; tyto stringy
    jsou u¾ivatelskými hodnotami výètu.  Odpovídající vnitøní hodnoty jsou
    blí¾e nespecifikované pythonové objekty s pythonovu sémantikou pravdy a
    nepravdy.
    
    """

    _SPECIAL_VALUES = ((True, 'T'), (False, 'F'), (None, ''))
    
    def __init__(self, not_null=True):
        e = FixedEnumerator((True, False))
        super(Boolean, self).__init__(enumerator=e, not_null=not_null)

    def _validate(self, object, extended=False):
        """Vra» instanci tøídy 'Value' s hodnotou definovanou pro 'object'.

        Je-li argument 'extended' pravdivý, jsou kromì \"oficiálních\" hodnot
        'object' zvalidovány i následující stringové hodnoty:

          \'t\', \'1\' -- jako reprezentace pravdivé hodnoty
          \'f\', \'0\', \'\' -- jako reprezentace nepravdivé hodnoty
        
        """
        if not extended and isinstance(object, str):
            object = string.strip(object)
            if object in ('t', '1'):
                object = 'T'
            elif object in ('', 'f', '0'):
                object = 'F'
        return super(Boolean, self)._validate(object)
    
    def default_value(self):
        return Value(self, False)


class Binary(Limited):
    """Binary data.

    External representation of a value of this type is either a Python 'buffer'
    object or 'None' (representing a null value).  Internal representation is
    an instance of the 'Buffer' class.  This is in general a wrapper of the
    Python buffer, which can add certain extended features, depending on the
    actual type of binary data contained within the buffer (such as report
    format or pixel size of an image, etc).  Thus each subclass of this type
    may define it's own 'Buffer' subclass with such extended features.

    Usage of binary data is limited only to certain situations.  They may be
    used only in non-key columns, they can be retrieved from a database (but
    they may not be used in search conditions with the exception of testing for
    NULL value) and they can be used as non-key values in insertions and
    updates.

    Values of this type are not cached as they may be large and their
    validation is trivial.

    """
    
    _VALIDATION_CACHE_LIMIT = 0
    _VM_MAXLEN_MSG = _("Pøekroèena maximální velikost %(maxlen)s")
    
    class Buffer(object):
        """Wrapper of a buffer for internal representation of binary values.

        The primary purpose of this class is to provide further validation of
        binary data depending on their content.  This class accepts any data,
        but subclasses may exist, which only accept certain binary formats,
        such as images, documents, audio files etc.

        Methods for loading binary data from files or saving them are also
        provided, but these are mostly here for convenience.
        
        """
        def __init__(self, data=None, path=None):
            """Initialize a new buffer instance and validate the input data.

            Arguemnts:
            
              data -- a Python buffer instance or None.  If used, 'path' must
                be None.
              path -- string path to an input file or None.  If used, 'data'
                must be None.

            The input data may be passed as a Python buffer instance or loaded
            from a file.  Just one of these methods may be used.

            The argument 'data' may be used as positional.
            
            Raises 'ValidationError' if the data don't conform to the binary
            format in use (depending on the actual 'Buffer' subclass).
            
            Raises 'IOError' if path is given and the file can not be read.
            
            """
            if data:
                assert path is None
                self._validate(data)
                self._buffer = data
            else:
                assert path is not None
                self.load(path)

        def __len__(self):
            return len(self._buffer)

        def _validate(self, data):
            if not isinstance(data, buffer):
                raise ValidationError(_("Not a buffer object: %r") % data)
            
        def buffer(self):
            """Return the binary data as a Python buffer instance."""
            return self._buffer

        def save(self, path):
            """Save the buffer data into a file.

            Arguemnts:
            
              path -- string path to the output file.
            
            Raises 'IOError' if the file can not be written.

            """
            f = open(path, 'wb')
            try:
                f.write(self._buffer)
            finally:
                f.close()
                
        def load(self, path):
            """Try to load the buffer from a file replacing the current data.

            Arguemnts:
            
              path -- string path to the input file.
            
            Raises 'IOError' if the file can not be read.

            Raises 'ValidationError' if the data format is invalid.

            The original buffer contents remains unchanged in case of any
            error.
            
            """
            f = open(path, 'rb')
            try:
                data = buffer(f.read())
            finally:
                f.close()
            self._validate(data)
            self._buffer = data
            
                
    def __init__(self, enumerator=None, **kwargs):
        assert enumerator is None, ("Enumerators may not be used "+
                                    "in binary data types")
        super(Binary, self).__init__(**kwargs)
        
    def _validate(self, object, **kwargs):
        return Value(self, self.Buffer(object)), None

    def _export(self, value):
        return value and value.buffer()

    def _format_maxlen(self):
        return format_byte_size(self._maxlen)
        
    
class Image(Binary, Big):
    """Binary type for generic bitmap images.

    The binary data of this type are represented by an 'Image.Buffer' instance.
    
    'Image.Buffer' validates the binary data to conform to one of input image
    formats supported by the Python Imaging Library.  It also provides the
    `image()' method, which returns the 'PIL.Image' instance corresponding to
    the image contained within the data.

    Image type can be further restricted to a list of allowed formats.  You may
    also restrict minimal/maximal pixel size of the image.

    Supported input formats include the most widely used formats such as 'PNG',
    'JPEG', 'TIFF', 'GIF', 'BMP', 'PCX', 'PPM', 'XBM' or 'IM'.  See Python
    Imaging Library documentation for the full list.

    The Python Imaging Library (PIL) must be installed when using this class.
    
    """
    
    VM_MAXSIZE = 'VM_MAXSIZE'
    _VM_MAXSIZE_MSG = _("Pøekroèena maximální velikost %(maxsize)s pixelù")
    VM_MINSIZE = 'VM_MINSIZE'
    _VM_MINSIZE_MSG = _("Nedodr¾ena minimální velikost %(minsize)s pixelù")
    VM_FORMAT = 'VM_FORMAT'
    _VM_FORMAT_MSG = _("Nepovolený formát %(format)s; povoleno: %(formats)s")
    
    class Buffer(Binary.Buffer):
        """A bufer for internal representation of bitmap image data.

        See the documentation of the 'Image' type for more information.

        """
        def _validate(self, data):
            super(Image.Buffer, self)._validate(data)
            import PIL.Image
            # The stream must stay open for the whole life of the Image object.
            f = StringIO(data)
            try:
                image = PIL.Image.open(f)
            except IOError:
                raise ValidationError(_("Neplatný grafický formát"))
            self._image = image
    
        def image(self):
            """Return the image as a 'PIL.Image' instance."""
            return self._image

    def __init__(self, minsize=(None, None), maxsize=(None, None),
                 formats=None, **kwargs):
        """Initialize the instance.
        
        Arguments:
        
          minsize -- maximal image size in pixels as a sequence of two integers
            (WIDTH, HEIGHT).  'None' in either value indicates an unlimited
            size in the corresponding direction...
          maxsize -- maximal image size in pixels; same rules as for 'minsize'
          formats -- list of allowed input formats as a sequence of strings,
            each string being one of PIL supported file formats, such as 'PNG',
            'JPEG', 'TIFF', 'GIF', 'BMP', 'PCX' etc.  Full list of the
            supported formats depends upon your PIL version.  If None, all
            formats supported by the Python Imaging Library are allowed.
          
        Other arguments are passed to the parent constructor.

        """
        if __debug__:
            for size in minsize, maxsize:
                assert isinstance(size, (tuple, list)) and len(size) == 2 and \
                       size[0] is None or isinstance(size[0], int) and \
                       size[1] is None or isinstance(size[1], int), size
            if formats is not None:
                assert isinstance(formats, (tuple, list)), formats
                for f in formats:
                    assert isinstance(f, str)
                    if f not in ('PNG', 'JPEG', 'TIFF', 'GIF', 'BMP',
                                 'PCX', 'PPM', 'XBM', 'IM'):
                        log(OPERATIONAL, "Suspicious image format:", f)
        self._minsize = tuple(minsize)
        self._maxsize = tuple(maxsize)
        self._formats = formats and tuple(formats)
        super(Image, self).__init__(**kwargs)

    def __cmp__(self, other):
        result = super(Image, self).__cmp__(other)
        if not result:
            result = cmp(self._minsize, other._minsize)
            if not result:
                result = cmp(self._maxsize, other._maxsize)
                if not result:
                    result = cmp(self._formats, other._formats)
        return result

    def minsize(self):
        """Return the minimal image size in pixels as a pair (WIDTH, HEIGHT).

        WIDTH and HEIGHT are integers or 'None' (denoting no limit).
        
        """
        return self._minsize

    def maxsize(self):
        """Return the maximal image size in pixels as a pair (WIDTH, HEIGHT).

        WIDTH and HEIGHT are integers or 'None' (denoting no limit).
        
        """
        return self._maxsize
    
    def formats(self):
        """Return the tuple of allowed input formats or None."""
        return self._formats
    
    def _check_constraints(self, value):
        super(Image, self)._check_constraints(value)
        if value is not None:
            image = value.image()
            for min,max,size in zip(self._minsize, self._maxsize, image.size):
                if min is not None and size < min:
                    raise self._validation_error(self.VM_MINSIZE,
                                               minsize='%sx%s' % self._minsize)
                if max is not None and size > max:
                    raise self._validation_error(self.VM_MAXSIZE,
                                               maxsize='%sx%s' % self._maxsize)
            if self._formats is not None and image.format not in self._formats:
                raise self._validation_error(self.VM_FORMAT,
                                             format=image.format,
                                             formats=', '.join(self._formats))
        

# Pomocné tøídy

class Enumerator(object):
    """Realizace výètu hodnot pou¾itelného pro integritní omezení datového typu.

    Enumerátor je pøedev¹ím poskytovatelem validace pro ovìøení, zda je nìjaká
    hodnota pøítomna v urèité mno¾inì hodnot.  Zpùsob ovìøení a urèení mno¾iny
    hodnot je pøedmìtem implementace rùzných tøíd enumerátorù.  Ovìøovaná
    hodnota je v¾dy vnitøní (Pythonovou) hodnotou typu, ve kterém je enumerátor
    pou¾it.

    Instanci enumerátoru je potom mo¾no pøedat konstruktoru datového typu a
    uvalit tak na daný typ pøíslu¹né integritní omezení.  Více informací také
    viz 'Type.__init__()'.
    
    Tato tøída pouze definuje povinné rozhraní enumerátorù.  Kromì zde
    definovaných povinných metod mohou konkrétní tøídy enumerátorù nabízet
    je¹tì dal¹í slu¾by.
    
    """
    def check(self, value):
        """Vra» pravdu, pokud 'value' je prvkem mno¾iny enumerátoru.

        Argumenty:
        
          value -- vnitøní (Pythonová) hodnota datového typu, pro který je
            enumerátor pou¾it.
        
        """
        raise ProgramError('Not implemented', 'Enumerator.check()')

    def values(self):
        """Vra» sekvenci v¹ech správných u¾ivatelských hodnot typu."""
        raise ProgramError('Not implemented', 'Enumerator.values()')


class FixedEnumerator(Enumerator):
    """Enumerátor pracující s fixní mno¾inou hodnot."""
    
    def __init__(self, enumeration):
        """Inicializuj instanci.
        
        Argumenty:
        
          enumeration -- sekvence hodnot kompatibilních s vnitøními
            (Pythonovými) hodnotami typu, pro který má být enumerátor pou¾it.
          
        """
        super(FixedEnumerator, self).__init__()
        self._enumeration = tuple(enumeration)

    def check(self, value):
        for v in self._enumeration:
            if v == value:
                return True
        return False

    def values(self):
        return self._enumeration
        
        
class MutableEnumerator(Enumerator):
    """Abstraktní tøída, kterou povinnì dìdí v¹echny mutable enumerátory.

    Mutable enumerátor takový, jeho¾ mno¾ina hodnot se mù¾e v èase mìnit.

    """
    def __init__(self):
        self._hooks = []
        self._running_hooks = False
    
    def _update(self, force=False):
        """Aktualizuj data enumerátoru.

        Bezprostøednì po zavolání této metody by mìl enumerátor pracovat
        s aktuálními daty.

        Argumenty:

          force -- právì kdy¾ je pravda, je update vynucený, jinak mù¾e a
            nemusí být proveden, vìt¹inou v závislosti na nároènosti operace

        Vrací: Pravdu, právì kdy¾ byl update skuteènì proveden.

        """
        if self._running_hooks:
            return True
        self._running_hooks = True
        try:
            for hook in self._hooks: hook()
        finally:
            self._running_hooks = False
        return True

    def add_hook_on_update(self, hook):
        self._hooks.append(hook)
        

class DataEnumerator(MutableEnumerator):
    """Enumerátor získávající své hodnoty z datového objektu.

    Hodnoty výètu jsou pythonové hodnoty urèitého sloupce datového objektu.
    Typicky je to klíèový sloupec ale pomocí argumentù konstruktoru je mo¾no
    zvolit libovolný jiný sloupec.

    """
        
    def __init__(self, data_factory, data_factory_kwargs={}, value_column=None,
                 validity_column=None, validity_condition=None):
        """Inicializuj instanci.
        
        Argumenty:
        
          data_factory -- instance tøídy 'DataFactory' slou¾ící k vytvoøení
            datového objektu pou¾itého k získání výètových hodnot.
            
          data_factory_kwargs -- dictionary klíèovaných argumentù pro metodu
            'DataFactory.create()'.
            
          value_column -- id sloupce datového objektu poskytujícího hodnoty
            enumerátoru.  Je-li None, bude pou¾it klíèový sloupec.

          validity_column -- id sloupce, urèujícího platnost øádkù datového
            zdroje.  Pokud je urèen (není None), budou za hodnoty výètu
            pova¾ovány pouze ty øádky, v nich¾ daný sloupec nabývá pravdivé
            hodnoty (musí jít o Boolean sloupec).  Není mo¾no pou¾ít v
            kombinaci s validity_condition.
          
          validity_condition -- podmínka urèující platnost øádkù datového
            zdroje.  Pokud je urèena, budou za hodnoty výètu pova¾ovány pouze
            ty øádky, v nich¾ je podmínka pravdivá.  Jde o obecnìj¹í variantu
            validity_column a nelze pou¾ít v kombinaci s tímto argumentem.
            
        """
        super(DataEnumerator, self).__init__()
        assert isinstance(data_factory, DataFactory), data_factory
        assert isinstance(data_factory_kwargs,
                          (types.DictType, types.TupleType))
        assert value_column is None or \
               isinstance(value_column, types.StringType)
        assert validity_column is None or \
               isinstance(validity_column, types.StringType) 
        assert validity_condition is None or \
               isinstance(validity_condition, pytis.data.Operator) \
               and validity_column is None
        # Store the arguments.
        self._data_factory = data_factory
        if type(data_factory_kwargs) == type(()):
            data_factory_kwargs = dict(data_factory_kwargs)
        self._data_factory_kwargs = data_factory_kwargs
        self._value_column_ = value_column
        self._validity_column = validity_column
        if validity_column is not None:
            validity_condition = EQ(validity_column, Value(Boolean(), True))
        self._validity_condition = validity_condition
        # Initialize the runtime filter.
        self._runtime_filter = None
        self._runtime_filter_dirty = True
        self._runtime_filter_provider = None
        self._runtime_filter_args = None

    def __getattr__(self, name):
        if name in ('_data', '_value_column'):
            self._complete()
            return self.__dict__[name]
        else:
            return super(DataEnumerator, self).__getattr__(name)
        
    def _complete(self):
        # Dokonèi instanci vytvoøením datového objektu.
        kwargs = self._data_factory_kwargs
        self._data = data = self._data_factory.create(**kwargs)
        self._data_changed = False
        def on_data_change():
            self._data_changed = True
        self._data.add_callback_on_change(on_data_change)
        if self._value_column_ is None:
            key = data.key()
            assert len(key) == 1, \
                   "Only single-column key is supported by DataEnumerator."
            self._value_column = key[0].id()
        else:
            self._value_column = self._value_column_
        c = data.find_column(self._value_column)
        assert c, ('Non-existent value column', self._value_column)
        self._value_column_type = c.type()
        if self._validity_column is not None:
            c = data.find_column(self._validity_column)
            assert c, ('Non-existent validity column', self._validity_column)
            assert isinstance(c.type(), Boolean), \
                   ('Invalid validity column type', c)

    def _retrieve(self, value):
        data = self._data
        v = Value(self._value_column_type, value)
        condition = EQ(self._value_column, v)
        validity_condition = self.validity_condition()
        if validity_condition is not None:
            condition = AND(condition, validity_condition)
        count = data.select(condition)
        if count > 1:
            raise ProgramError('Insufficient runtime filter for DataEnumerator',
                               str(condition))
        row = data.fetchone()
        data.close()
        return row

    def _update(self, force=False):
        if force or self._data_changed:
            self._data_changed = False
            result = super(DataEnumerator, self)._update(force=force)
        else:
            result = False
        return result

    # Enumerator interface
    
    def check(self, value):
        row = self._retrieve(value)
        if row is None:
            result = False
        else:
            result = True
        return result

    def values(self):
        result = self._data.select_map(lambda r: r[self._value_column].value(),
                                       condition=self.validity_condition())
        return tuple(result)
        

    # Extended interface.

    def data_factory(self):
        """Vra» specifikaci datového jako instanci 'pytis.data.DataFactory'."""
        return self._data_factory
    
    def value_column(self):
        """Vra» název sloupce datového objektu, který nese vnitøní hodnotu."""
        return self._value_column
    
    def get(self, value, column=None):
        """Získej z dat hodnotu daného sloupce z øádku odpovídajícího 'value'.

        Argumenty:
        
           value -- vnitøní (Pythonová) hodnota sloupce 'value_column' z
             datového objektu.  Podle této hodnoty bude vyhledán pøíslu¹ný
             øádek.
           column -- identifikátor sloupce datového objektu, jeho¾ hodnota má
             být vrácena.

        Vrací instanci 'Value', nebo None, pokud daný øádek nebyl nalezen.

        """
        row = self._retrieve(value)
        if row is None:
            result = None
        else:
            if column is None:
                column = self._value_column
            result = row[column]
        return result

    def type(self, column):
        """Vra» datový typ daného sloupce v datovém objektu enumerátoru."""
        return self._data.find_column(column).type()

    def iter(self):
        """Vra» iterátor, iterující pøes v¹echny datové øádky."""
        # TODO: Asi by bylo èist¹í pøedefinovat metodu values a tu potom
        # pou¾ívat v kombinaci s metodou get.  Aby se ov¹em v get neprovádìl
        # zbyteènì nový select, bylo by nutné si nìjak internì pamatovat
        # poslední øádek a v metodì get jej potom rovnou pou¾ít, pokud je to
        # øádek po¾adované hodnoty.
        self._data.select(self.validity_condition())
        def fetchone():
            row = self._data.fetchone()
            if row is None:
                self._data.close()
            return row
        return iter(fetchone, None)

    # Run-time filter interface.

    def set_runtime_filter_provider(self, provider, args):
        """Nastav poskytovatele run-time podmínky filtrující øádky enumerátoru.

        Argumenty:
        
          provider -- None, nebo funkce, která vrací instanci tøídy 'Operator'.
            Tato funkce bude volána v¾dy, kdy¾ je tøeba zjistit dodateènou
            filtrovací podmínku.
          args -- seznam argumentù (tuple), které mají být pøedány této funkci.

        Run-time podmínka umo¾òuje mìnit mno¾inu platných øádkù enumerátoru za
        bìhu.  Po externí zmìnì podmínky je tøeba toto oznámit voláním
        'notify_runtime_filter_change()'.  Tím je zaji¹tìno, ¾e pøi v¹ech
        následných operacích s enumerátorem bude podmínka automaticky
        pøepoèítána a mno¾ina platných hodnot enumerátoru bude aktualizována.

        """
        assert callable(provider) or provider is None
        self._runtime_filter_provider = provider
        self._runtime_filter_args = args

    def notify_runtime_filter_change(self):
        """Ohlas zmìnu run-time filtrovací podmínky.

        Tato metoda by mìla být volána v¾dy, kdy¾ dojde k externí zmìnì
        run-time filtrovací podmínky.  Enumerátor se tak dozví, ¾e si má v
        pøípadì potøeby zjistit novou hodnotu podmínky (viz metoda
        'set_runtime_filter_provider()').
        
        """
        self._runtime_filter_dirty = True
        self._update(force=True)
        
    
    def validity_condition(self):
        """Vra» podmínku urèující platné øádky enumerátoru.
        
        Podmínka zahrnuje jak statické omezení øádkù enumerátoru, tak aktuální
        hodnotu run-time podmínky

        Vrací: Instanci tøídy 'pytis.data.Operator'.

        """
        f = self._runtime_filter_provider
        if f is not None:
            if self._runtime_filter_dirty:
                self._runtime_filter = flt = apply(f, self._runtime_filter_args)
                assert isinstance(flt, Operator) or flt is None
                self._runtime_filter_dirty = False
                self._update(force=True)
            condition = self._runtime_filter
        else:
            condition = None
        if self._validity_condition:
            if condition:
                return AND(condition, self._validity_condition)
            else:
                return self._validity_condition
        else:
            return condition


class ValidationError(Exception):
    """Popis chyby pøi neúspìchu validace v 'Type.validate'.

    Popis lze získat veøejnou metodou 'message'.  Popisem je string a mìl by
    být srozumitelný jako zpráva pro u¾ivatele.
    
    """
    def __init__(self, message):
        """Inicializuj zprávu o chybì.

        Argumenty:
        
          message -- string obsahující zprávu o chybì pro u¾ivatele
         
        """
        super_(ValidationError).__init__(self, message)
        self._message = message

    def __str__(self):
        return '<ValidationError: ' + self.message() + '>'

    def message(self):
        """Vra» zprávu o chybì jako string srozumitelný pro u¾ivatele."""
        return self._message


class _Value(object):
    """Obecná reprezentace hodnoty daného typu.

    Ka¾dá hodnota se skládá z typu (instance tøídy 'Type') a hodnoty samotné.
    Hodnota samotná mù¾e být cokoliv, bez ohledu na uvedený typ.

    """
    def __init__(self, type, value):
        """Inicializuj instanci.

        Argumenty:
        
          type -- instance tøídy 'Type'
          value -- hodnota samotná, libovolný objekt

        """
        self._type = type
        self._value = value

    def __getstate__(self):
        return {'_type': self._type,
                '_value': self._value}

    def __setstate__(self, state):
        type = state['_type']
        if not isinstance(type, Type):
            raise InvalidAccessError('Invalid argument type', '_Value.type',
                                     type)
        self._type = type
        self._value = state['_value']
    
    def __unicode__(self):
        type = self.type()
        value = unicode (self.value())
        if isinstance(type, Big) and len(value) > 40:
            value = '%s...<<big value>>...' % (value[:10],)
        return '<%s: type=%s, value=%s>' % (self.__class__.__name__,
                                            type, value)

    def __cmp__(self, other):
        """Vra» 0, právì kdy¾ 'self' a 'other' jsou shodné.

        'self' a 'other' jsou shodné, právì kdy¾ se rovnají jejich typy a
        hodnoty.
        
        """
        if sameclass(self, other):
            t1, t2 = self.type(), other.type()
            if t1 == t2:
                res = 0
            else:
                res = compare_objects(t1, t2)
            if res:
                return res
            else:
                #return compare_objects(self.value(), other.value())
                return cmp(self.value(), other.value())
        else:
            return compare_objects(self, other)

    def type(self):
        """Vra» typ hodnoty jako instanci tøídy 'Type' zadanou v '__init__()'.
        """
        return self._type

    def value(self):
        """Vra» hodnotu zadanou v '__init__()'."""
        return self._value


class Value(_Value):
    """Reprezentace hodnoty daného typu.

    Ka¾dá hodnota se skládá z typu (instance tøídy 'Type') a hodnoty samotné.
    Hodnota samotná mù¾e být cokoliv, bez ohledu na uvedený typ.

    Pro zápis hodnoty do u¾ivatelského rozhraní nebo databáze lze vyu¾ít metodu
    'export()'.
    
    """
    _VOID = object()
    
    def __init__(self, type, value):
        """Inicializuj hodnotu daného typu.

        Argumenty:
        
          type -- instance tøídy 'Type'
          value -- hodnota samotná, libovolný objekt
         
        """
        _Value.__init__(self, type, value)
        self._init()

    def __setstate__(self, state):
        super(Value, self).__setstate__(state)
        self._init()
        
    def _init(self):
        if self._type.__class__ == String:    # pozor, nebezpeèná vìc!
            e = self._value or ''
            self._exported = isinstance(e, unicode) and e or unicode(e)
        else:
            self._exported = self._VOID
        
    def export(self, *args, **kwargs):
        """Vra» stringovou reprezentaci hodnoty schopnou validace.

        Tato metoda je pouze zkratkou pro volání
        'self.type().export(self.value())'.  Pokud jsou metodì pøedány
        argumenty, je metoda `Type.export()' volána i s tìmito argumenty.
        
        """
        # Abychom to zbyteènì nekomplikovali, tak cachujeme pouze exporty bez
        # argumentù.
        if args or kwargs:
            exported = apply(self.type().export,
                             (self.value(),) + args, kwargs)
        else:
            exported = self._exported
            if exported is self._VOID:
                exported = self.type().export(self.value())
                self._exported = exported
        return exported


class WMValue(_Value):
    """Reprezentace specifikace pro wildcard match daného typu."""


# TODO: Temporary type specific to PostgreSQL, currently heavily used in
# applications.  It should be completely removed in the future.
class Oid(Integer):
    """Typ sloupce oid v PostgreSQL."""
