# -*- coding: iso-8859-2 -*-

# Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006 Brailcom, o.p.s.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""Práce s formuláøi se seznamovým zobrazením.

Modul jednak interpretuje specifikaci formuláøù (viz modul 'spec') pro
seznamové zobrazení a jednak zaji¹»uje práci s ní prostøednictvím objektù
wxWindows.

"""

# Terminologická poznámka: Promìnné s názvem `row' obvykle znaèí èíslo øádku
# (èíslováno od 0).  Jedná-li se o obsah øádku, nazývá se pøíslu¹ná promìnná
# obvykle `the_row'.  Matoucí jméno `row' bylo pøevzato z wxWindows.

import copy
import string
import time
import types

import wx
import wx.grid

from pytis.form import *
import pytis.data
import pytis.output
import pytis.presentation
from pytis.presentation import PresentedRow

import _grid

import config
    
### Formuláøe


class ListForm(LookupForm, TitledForm, Refreshable):
    """Spoleèná nadtøída pro formuláøe se seznamovým zobrazením.

    Tyto formuláøe zobrazují seznam øádkù, rozdìlených do nìkolika sloupcù,
    tedy v podstatì tabulku.  Tøída definuje spoleèné vlastnosti, jako mo¾nosti
    navigace, vyhledávání, øazení apod.

    Tøída je 'CallbackHandler' a jako argument callbackové funkce pøedává
    slovník, jeho¾ klíèe jsou id sloupcù (stringy) a hodnoty jsou hodnoty
    tìchto sloupcù (opìt stringy) øádku, jeho¾ se callback týká.

    Tato tøída obvykle není pou¾ívána pøímo, nýbr¾ slou¾í jako základ pro
    specializované tøídy.

    """
    CALL_ACTIVATION = 'CALL_ACTIVATION'
    """Konstanta callbacku aktivace øádku."""
    CALL_MODIFICATION = 'CALL_MODIFICATION'
    """Konstanta callbacku modifikace øádku."""
    CALL_USER_INTERACTION = 'CALL_USER_INTERACTION'
    """Konstanta callbacku interakce u¾ivatele."""

    _REFRESH_PERIOD = 60 # sekund
    _SELECTION_CALLBACK_DELAY = 3 # desítky milisekund
    _TITLE_FOREGROUND_COLOR = WxColor(210, 210, 210)
    
    _STATUS_FIELDS = ('list-position', 'data-changed')


    def __init__(self, *args, **kwargs):
        super_(ListForm).__init__(self, *args, **kwargs)
        # Nastav klávesové zkratky z kontextových menu.
        for item in self._context_menu() + self._edit_menu():
            if isinstance(item, MItem):
                if item.hotkey() != (None,):
                    self.define_key(item.hotkey(), item.command(), item.args())
        # Závìreèné akce
        self._data.add_callback_on_change(self.on_data_change)
        wx_callback(wx.EVT_SIZE, self, self._on_size)
        self._select_cell(row=self._position)
        self.set_callback(ListForm.CALL_ACTIVATION, self._on_activation)

    def _init_attributes(self, columns=None, **kwargs):
        """Zpracuj klíèové argumenty konstruktoru a inicializuj atributy.

        Argumenty:

          columns -- pokud není None, bude formuláø pou¾ívat dané sloupce.
            Jinak je pou¾it seznam sloupcù daný specifikací.  Hodnotou je
            sekvence identifikátorù sloupcù obsa¾enýh ve specifikaci.
          kwargs -- argumenty pøedané konstruktoru pøedka.

        """
        super_(ListForm)._init_attributes(self, **kwargs)
        self._default_columns_changed = False
        assert columns is None or is_sequence(columns)
        if not columns:
            default = self._default_columns()
            columns = self._get_state_param('columns', default)
            if default != self._get_state_param('default_columns', default):
                self._default_columns_changed = True
                columns = [id for id in columns
                           if self._view.field(id) is not None]
        self._columns = [self._view.field(id) for id in columns]
        # Inicializace atributù
        self._fields = self._view.fields()
        self._enable_inline_insert = self._view.enable_inline_insert()
        self._selection_candidate = None
        self._selection_callback_candidate = None
        self._selection_callback_tick = None
        self._in_select_cell = False
        self._last_reshuffle_request = self._reshuffle_request = 0
        self._current_editor = None
        self._column_to_move = None
        self._column_move_target = None
        self._mouse_dragged = False
        # Parametry zobrazení
        self._initial_position = self._position = 0

    def _default_columns(self):
        return self._view.columns()
        
    def _default_grouping(self):
        return self._view.grouping()

    def _default_sorting(self):
        view = self._view
        sorting = view.sorting()
        if sorting is None:
            key = filter(lambda k: view.field(k.id()) is not None,
                         self._data.key())
            sorting = tuple(map(lambda k: (k.id(),
                                           LookupForm.SORTING_DESCENDANT),
                                key))
        return sorting
        
    def _create_form_parts(self, sizer):
        title = self.title()
        if title is not None:
            description = self._view.description()
            self._title_bar = self._create_title_bar(title,
                                                     description=description)
            sizer.Add(self._title_bar, 0, wx.EXPAND|wx.FIXED_MINSIZE)
        else:
            self._title_bar = None
        self._grid = self._create_grid()
        self._update_colors()
        sizer.Add(self._grid, 1, wx.EXPAND|wx.FIXED_MINSIZE)

    def _column_width(self, column):
        try:
            #TODO: Column widths should be saved/restored in dialog units.
            return self._get_state_param('column_width', {})[column.id()]
        except KeyError:
            width = max(column.column_width(), len(column.column_label()))
            return dlg2px(self._grid, 4*width + 8)

    def _create_grid(self):
        if __debug__: log(DEBUG, 'Vytváøení nového gridu')
        # Vytvoø grid a tabulku
        g = wx.grid.Grid(self, wx.NewId())
        # Inicializuj datový select
        row_count = self._init_select()
        self._table = table = \
          _grid.ListTable(self._parent, self._data, self._fields,
                          self._columns, row_count, sorting=self._lf_sorting,
                          grouping=self._lf_grouping, prefill=self._prefill,
                          row_style=self._view.row_style())
        g.SetTable(table, True)
        g.SetRowLabelSize(0)
        g.SetColLabelSize(dlg2px(g, 0, 12).GetHeight())
        g.SetColLabelAlignment(wx.CENTER, wx.CENTER)
        g.SetMargins(0,0)
        g.DisableDragGridSize()
        g.SetSelectionMode(wx.grid.Grid.wxGridSelectRows)
        labelfont = g.GetLabelFont()
        labelfont.SetWeight(wx.NORMAL)
        g.SetLabelFont(labelfont)
        g.SetDefaultRowSize(dlg2px(g, 0, 10).GetHeight())
        # (Re)inicializuj atributy instance a gridu
        self._editors = []
        def registration(editor):
            self._current_editor = editor
        editable = False
        for i, c in enumerate(self._columns):
            # typ sloupce
            t = c.type(self._data)
            # zarovnání
            attr = wx.grid.GridCellAttr()
            if isinstance(t, pytis.data.Number):
                alignment = wx.ALIGN_RIGHT
            else:
                alignment = wx.ALIGN_LEFT
            attr.SetAlignment(alignment, wx.CENTER)
            # editor
            editable = c.editable()
            if editable or editable in (Editable.ALWAYS, Editable.ONCE):
                editable = True
                editor = _grid.InputFieldCellEditor(self._parent, table, self,
                                                    c, self._data, registration)
                editor.set_callback(InputField.CALL_LEAVE_FIELD,
                                    self._on_cell_rollback)
                editor.set_callback(InputField.CALL_COMMIT_FIELD, 
                                    self._on_cell_commit)
                self._editors.append(editor)
                attr.SetEditor(editor)
            else:
                attr.SetReadOnly()
            g.SetColAttr(i, attr)
        self.editable = editable
        labels = g.GetGridColLabelWindow()
        # Event handlery
        wx_callback(wx.grid.EVT_GRID_SELECT_CELL,   g, self._on_select_cell)
        wx_callback(wx.grid.EVT_GRID_COL_SIZE,      g, self._on_label_drag_size)
        wx_callback(wx.grid.EVT_GRID_EDITOR_SHOWN,  g, self._on_editor_shown)
        wx_callback(wx.grid.EVT_GRID_CELL_RIGHT_CLICK, g, self._on_context_menu)
        wx_callback(wx.EVT_MOUSEWHEEL, g,      self._on_wheel)
        wx_callback(wx.EVT_IDLE,       g,      self._on_idle)
        wx_callback(wx.EVT_KEY_DOWN,   g,      self.on_key_down)
        wx_callback(wx.EVT_LEFT_DOWN,  labels, self._on_label_left_down)
        wx_callback(wx.EVT_LEFT_UP,    labels, self._on_label_left_up)
        wx_callback(wx.EVT_RIGHT_DOWN, labels, self._on_label_right_down)
        wx_callback(wx.EVT_MOTION,     labels, self._on_label_mouse_move)
        wx_callback(wx.EVT_PAINT,      labels, self._on_label_paint)
        if __debug__: log(DEBUG, 'Nový grid vytvoøen')
        return g

    def _on_editor_shown(self, event):
        if self._table.editing():
            event.Skip()
        else:
            event.Veto()
            self._select_cell(row=max(0, event.GetRow()), col=event.GetCol())
    
    def _update_grid(self, data_init=False, inserted_row_number=None,
                     inserted_row=None, delete_column=None, insert_column=None,
                     inserted_column_index=None, reset_columns=False):
        g = self._grid
        t = self._table
        def notify(id, *args):
            msg = wx.grid.GridTableMessage(t, id, *args)
            g.ProcessTableMessage(msg)
        current_row = self._table.current_row()
        if data_init:
            row_count = self._init_select()
        else:
            row_count = self._lf_select_count
            self._data.rewind()
        if inserted_row_number is not None:
            row_count = row_count + 1
        old_row_count = self._table.GetNumberRows()
        new_row_count = row_count
        old_columns = tuple([c.id() for c in self._columns])
        # Uprav velikost gridu
        g.BeginBatch()
        if reset_columns:
            deleted = len(self._columns)
            self._columns = [self._view.field(id)
                             for id in self._default_columns()]
            inserted = len(self._columns)
            notify(wx.grid.GRIDTABLE_NOTIFY_COLS_DELETED, 0, deleted)
            notify(wx.grid.GRIDTABLE_NOTIFY_COLS_INSERTED, 0, inserted)
        if delete_column is not None:
            i = self._columns.index(delete_column)
            del self._columns[i]
            notify(wx.grid.GRIDTABLE_NOTIFY_COLS_DELETED, i, 1)
        if insert_column is not None:
            if inserted_column_index is None:
                i = len(self._columns)
            else:
                i = inserted_column_index
            self._columns.insert(i, insert_column)
            notify(wx.grid.GRIDTABLE_NOTIFY_COLS_INSERTED, i, 1)
        new_columns = tuple([c.id() for c in self._columns])
        if reset_columns:
            self._unset_state_param('columns')
            self._unset_state_param('default_columns')
        elif new_columns != old_columns:
            self._set_state_param('columns', new_columns)
            self._set_state_param('default_columns', self._default_columns())
        t.update(columns=self._columns,
                 row_count=row_count, sorting=self._lf_sorting,
                 grouping=self._lf_grouping,
                 inserted_row_number=inserted_row_number,
                 inserted_row=inserted_row, prefill=self._prefill)
        ndiff = new_row_count - old_row_count
        if new_row_count < old_row_count:
            if new_row_count == 0:
                current_row = 1
            notify(wx.grid.GRIDTABLE_NOTIFY_ROWS_DELETED, current_row, -ndiff)
        elif new_row_count > old_row_count:
            notify(wx.grid.GRIDTABLE_NOTIFY_ROWS_APPENDED, ndiff)
        notify(wx.grid.GRIDTABLE_REQUEST_VIEW_GET_VALUES)
        g.EndBatch()
        # Závìreèné úpravy
        if new_row_count != old_row_count:
            # This is a workaround of a wxWidgets bug.  The scrollbars are not
            # shown or hidden properly, until a size event is received by the
            # grid.  Thus we generate one artificially...
            g.SetSize(g.GetSize())
        # Tento _select_cell() zde nemù¾e být, proto¾e vyvolá ukonèení editace
        # pøi vkládání øádku.  Pokud to je nìkdy potøeba, bude nutné volat
        # _select_cell() zvlá¹» po _update_grid().  Zatím to ale spí¹ vypadá,
        # ¾e je to tady zbyteènì (kostlivec).  TC 2005-12-28
        #self._select_cell(row=self._position)
        self._update_colors()
        self._resize_columns()


    def _update_label_colors(self):
        color = self._lf_indicate_filter and config.filter_color or \
                self._TITLE_FOREGROUND_COLOR
        self._grid.SetLabelBackgroundColour(color)

    def _context_menu(self):
        """Vra» specifikaci \"kontextového\" popup menu vybrané buòky seznamu.

        Vrací: Sekvenci instancí 'MItem'.

        Tuto metodu nech» odvozené tøídy pøedefinují, pokud chtìjí zobrazovat
        kontextové menu.
        
        """
        return ()

    def _edit_menu(self):
        return (
            MItem("Editovat buòku",
                  command = ListForm.COMMAND_EDIT),
            MItem("Ulo¾it záznam",
                  command = ListForm.COMMAND_LINE_COMMIT),
            MItem("Opustit editaci",
                  command = ListForm.COMMAND_FINISH_EDITING),
            MSeparator(),
            MItem("Kopírovat obsah buòky",
                  command = ListForm.COMMAND_COPY_CELL),
            #MItem("", command = ListForm.COMMAND_LINE_ROLLBACK),
            )

    def _lf_sfs_columns(self):
        shown = tuple(self._columns)
        hidden = tuple([c for c in self._view.fields()
                        if c not in shown and c.column_label()])
        def labelfunc(c):
            label = c.column_label()
            if c in hidden:
                return "(" + label + ")"
            else:
                return label
        return sfs_columns(shown + hidden, self._data, labelfunc=labelfunc)
    
    # Pomocné metody

    def _current_cell(self):
        """Vra» dvojici souøadnic (ROW, COL) aktuální buòky."""
        g = self._grid
        return g.GetGridCursorRow(), g.GetGridCursorCol()

    def current_row(self):
        row = self._current_cell()[0]
        if row < 0 or row >= self._grid.GetNumberRows():
            # Pøi prázdné tabulce má wxGrid nastaven øádek 0.
            return None
        else:
            return self._table.row(row)
        
    def _select_cell(self, row=None, col=None, invoke_callback=True):
        # Vrací pravdu, pokud mù¾e být událost provedena (viz _on_select_cell).
        if self._in_select_cell:
            return True
        self._in_select_cell = True
        if __debug__: log(DEBUG, 'Pøechod na buòku gridu:', (row, col))
        try:
            g = self._grid
            current_row = g.GetGridCursorRow()
            current_col = g.GetGridCursorCol()
            if row is not None:
                assert isinstance(row, types.IntType)
                # Zkontroluj pøípadné opu¹tìní editace
                if not self._finish_editing(row=row):
                    log(EVENT, 'Zamítnuto opu¹tìní editace øádku')
                    return False
                else:
                    if row < 0 or row >= g.GetNumberRows():
                        if g.IsSelection():
                            g.ClearSelection()
                        row = 0
                    else:
                        if col is None:
                            col = max(0, current_col)
                        g.SetGridCursor(row, col)
                        g.MakeCellVisible(row, col)
                        self._selection_candidate = (row, col)
                        if invoke_callback:
                            # Nevoláme callback ihned, staèí a¾ po
                            # zastavení scrolování...
                            self._selection_callback_candidate = row
                            delay = self._SELECTION_CALLBACK_DELAY
                            self._selection_callback_tick = delay
                    self._position = row
                    # TODO: tady to zpùsobuje ¹patné zobrazování pozice v
                    #       dualform. Nahrazeno voláním show_position v
                    #       _post_selection_hook.
                    #       Jiné øe¹ení?
                    # self.show_position()
            elif col is not None and col != current_col:
                g.SetGridCursor(current_row, col)
                g.MakeCellVisible(current_row, col)
            if __debug__: log(DEBUG, 'Výbìr buòky proveden:', (row, col))
            return True
        finally:
            self._in_select_cell = False

    def _edit_cell(self):
        """Spus» editor aktuálního políèka."""
        row, col = self._current_cell()
        table = self._table
        cid = self._columns[col].id()
        if not table.row(table.editing().row).editable(cid):
            message(_("Políèko je needitovatelné"), kind=ACTION, beep_=True)
            return False
        self._grid.EnableCellEditControl()       
        log(EVENT, 'Spu¹tìn editor políèka:', (row, col))
        return True
    
    def _finish_editing(self, question=None, row=None):
        # Vrací pravdu, právì kdy¾ nejsou akce blokovány editací øádku.
        
        table = self._table
        editing = table.editing()
        if not editing:
            return True
        if editing.row == row:
            return True
        if not editing.changed:
            if __debug__: log(DEBUG, 'Odchod z needitovaného øádku povolen')
            self._on_line_rollback()
            finish = True 
        else:
            log(EVENT, 'Pokus o odchod z rozeditovaného øádku seznamu')
            if question == None:
                question = _("Zru¹it zmìny záznamu?")
            buttons = bcancel, bsave, bcontinue = \
                      _("Zru¹it"), _("Ulo¾it"), _("Pokraèovat v editaci")
            result = run_dialog(MultiQuestion, question, buttons=buttons,
                                default=bsave)
            finish = (result != bcontinue)
            if result == bcancel:
                log(EVENT, 'Odchod u¾ivatelem povolen')
                self._on_line_rollback()
                finish = True
            elif result == bsave:
                log(EVENT, 'Odchod s ulo¾ením øádku')
                finish = self._on_line_commit()
            elif result is None or result == bcontinue:
                log(EVENT, 'Odchod u¾ivatelem zamítnut')
                finish = False
            else:
                raise ProgramError('Unexpected dialog result', result)
        return finish

    def _update_selection_colors(self):
        if focused_window() is self:
            if self._table.editing():
                foreground = config.row_edit_fg_color
                background = config.row_edit_bg_color
            else:
                foreground = config.row_focus_fg_color
                background = config.row_focus_bg_color
                if background is None:
                    c = wx.SYS_COLOUR_HIGHLIGHT
                    background = wx.SystemSettings.GetColour(c)

        else:
            foreground = config.row_nofocus_fg_color
            background = config.row_nofocus_bg_color
        g = self._grid
        if foreground is not None and foreground != g.GetSelectionForeground():
            g.SetSelectionForeground(foreground)
        if background is not None and background != g.GetSelectionBackground():
            g.SetSelectionBackground(background)
        # Musíme vynutit pøekreslení celé selection
        if g.IsSelection():
            g.ClearSelection()
            g.SelectRow(g.GetGridCursorRow())
        
    def _is_editable_cell(self, row, col):
        # Vra» pravdu, pokud je buòka daného øádku a sloupca editovatelná.
        editing = self._table.editing()
        if row == editing.row:
            the_row = editing.the_row
        else:
            the_row = self._table.row(row)
        id = self._columns[col].id()
        return the_row.editable(id)
    
    def _find_next_editable_cell(self):
        # Vra» pravdu, pokud bylo pohybem vpravo nalezeno editovatelné políèko.
        row, col = self._current_cell()
        while self._grid.MoveCursorRight(False):
            col += 1
            if self._is_editable_cell(row, col):
                self._edit_cell()
                return True

    def _search_adjust_data_position(self, row_number):
        if row_number is None:
            row_number = self._current_cell()[0]
        self._table.rewind(position=row_number)

    def _search_skip(self, skip, direction):
        if direction == pytis.data.BACKWARD:
            skip = -skip
        row, col = self._current_cell()
        new_row = row + skip
        self._table.rewind(position=new_row)
        self._select_cell(row=new_row)

    def _filter(self, condition):
        # TODO: Jak to bylo my¹leno?
        # if self._lf_initial_condition:
        #      xcondition = pytis.data.AND(condition, self._lf_initial_condition)
        # else:
        #      xcondition = condition
        log(EVENT, 'U¾ivatelský filtr:', condition)
        self._refresh(reset={'condition': condition,
                             'filter_flag': condition},
                      when=self.DOIT_IMMEDIATELY)

    def _filter_by_cell(self, cancel=False):
        row, col = self._current_cell()
        id = self._columns[col].id()
        sf_dialog = self._lf_sf_dialog('_lf_filter_dialog', FilterDialog)
        if sf_dialog.append_condition(id, self._table.row(row)[id]):
            self._on_filter(show_dialog=False)
        else:
            message(_("Podle tohoto sloupce nelze filtrovat."), beep_=True)

    def _resize_column(self, diff=5):
        # diff can be positive or negative integer in pixels.
        g = self._grid
        col = g.GetGridCursorCol()
        newsize = g.GetColSize(col) + diff
        if newsize > 0:
            g.SetColSize(col, newsize)
            g.SetSize(g.GetSize())
            g.Refresh()
            self._remember_column_size(col)

    def _move_column(self, diff=1):
        col = self._grid.GetGridCursorCol()
        newcol = col + diff
        if 0 <= newcol < len(self._columns):
            c = self._columns[col]
            self._update_grid(delete_column=c, insert_column=c,
                              inserted_column_index=newcol)
            self._select_cell(col=newcol)
        else:
            log(OPERATIONAL, "Invalid column move command:", (col, newcol))

    def can_move_column(self, diff=1):
        col = self._grid.GetGridCursorCol()
        return 0 <= col + diff < len(self._columns)
        
    def _on_sort_column(self, col=None, direction=None, primary=False):
        if not self._finish_editing():
            return
        if col is not None:
            col = self._columns[col].id()
            if not self._data.find_column(col):
                message(_("Podle tohoto sloupce nelze tøídit"),
                        beep_=True)
                return
        old_sorting = self._lf_sorting
        sorting = super_(ListForm)._on_sort_column(self, col=col,
                                                   direction=direction,
                                                   primary=primary)
        if sorting is not None and sorting != old_sorting:
            self._refresh(reset={'condition':self._lf_condition,
                                 'sorting':sorting},
                          when=self.DOIT_IMMEDIATELY)
        return sorting

    def can_sort_column(self, **kwargs):
        col = kwargs.get('col')
        if col is not None:
            kwargs['col'] = self._columns[col].id()
        return super(ListForm, self).can_sort_column(**kwargs)
            
    # Callbacky

    def on_data_change(self):
        """Callback, který lze zavolat pøi zmìnì dat v datovém zdroji.

        Metoda je urèena pro registraci pomocí metody
        'pytis.data.Data.add_callback_on_change'.

        Metoda naopak není urèena pro ¾ádost o okam¾itý update, proto¾e pouze
        zadá po¾adavek na update, který je zpracován a¾ za blí¾e neurèenou
        dobu.  K pøímým updatùm slou¾í metody 'reset()' a 'refresh()'.

        """
        log(EVENT, 'Notifikace o zmìnì dat øádkového seznamu')
        now = time.time()
        maybe_future = self._last_reshuffle_request + self._REFRESH_PERIOD
        self._reshuffle_request = max(now, maybe_future)
        self._show_data_status()

    def _on_idle(self, event):
        if self._selection_candidate is not None:
            row, col = self._selection_candidate
            self._selection_candidate = None
            self._grid.SelectRow(row)
            self._update_selection_colors()
            self._grid.MakeCellVisible(row, col)
        if self._selection_callback_candidate is not None:
            if self._selection_callback_tick > 0:
                self._selection_callback_tick -= 1
                microsleep(100)
                event.RequestMore()
            else:
                row = self._selection_callback_candidate
                self._selection_callback_candidate = None
                the_row = self._table.row(row)
                if the_row is not None:
                    self._run_callback(self.CALL_SELECTION, (the_row,))
                    self._post_selection_hook(the_row)
        if self._default_columns_changed:
            self._default_columns_changed = False
            msg = _("Specifikace sloupcù formuláøe byla zmìnìna.\n"
                    "Va¹e u¾ivatelské nastavení sloupcù je ji¾ zastaralé.\n"
                    "Chcete pou¾ít nové výchozí nastavení sloupcù?")
            if run_dialog(Question, msg):
                self._on_reset_columns()
            else:
                self._set_state_param('default_columns',self._default_columns())
        # V budoucnu by zde mohlo být pøednaèítání dal¹ích øádkù nebo dat
        event.Skip()
        return False

    def _post_selection_hook(self, the_row):
        if focused_window() is self:
            # TODO: viz poznámka v _select_cell.
            self.show_position()
            # Zobraz hodnotu displeje z èíselníku ve stavové øádce.
            column = self._columns[self._current_cell()[1]]
            value = the_row[column.id()]
            enumerator = value.type().enumerator()
            display_value = ''
            if enumerator and column.codebook():
                try:
                    cb_spec = resolver().get(column.codebook(), 'cb_spec')
                except ResolverError:
                    cb_spec = None
                except AttributeError:
                    cb_spec = None
                if cb_spec and cb_spec.display():
                    try:
                        v = enumerator.get(value.value(), cb_spec.display())
                        if v:
                            display_value = v.export()
                    except pytis.data.DataAccessException:
                        pass
            message(display_value)
    
    def _on_select_cell(self, event):
        if not self._in_select_cell and self._grid.GetBatchCount() == 0:
            # GetBatchCount zji¹»ujeme proto, aby nedhocházelo k volání
            # callbacku pøi zmìnách v rámci _update_grid(), které nejsou
            # interaktivní.
            self._run_callback(self.CALL_USER_INTERACTION)
        if self._select_cell(row=max(0, event.GetRow()), col=event.GetCol()):
            # SetGridCursor vyvolá tento handler.  Aby SetGridCursor mìlo
            # vùbec nìjaký úèinek, musíme zde zavolat originální handler, který
            # po¾adované nastavení buòky zajistí.
            event.Skip()
        else:
            event.Veto()
            self._grid.SelectRow(self._grid.GetGridCursorRow())

    def _on_activation(self, key, alternate=False):
        if alternate:
            f = DescriptiveDualForm
        else:
            f = BrowsableShowForm
        self._run_form(f, key)

    def _scroll_x_offset(self):
        g = self._grid
        return g.GetViewStart()[0] * g.GetScrollPixelsPerUnit()[0]
            
    def _on_label_right_down(self, event):
        self._run_callback(self.CALL_USER_INTERACTION)
        g = self._grid
        col = g.XToCol(event.GetX() + self._scroll_x_offset())
        # Menu musíme zkonstruovat a¾ zde, proto¾e argumentem pøíkazù je èíslo
        # sloupce, které zjistím a¾ z eventu.
        items = (Menu(_("Primární øazení"),
                      (MItem(_("Øadit vzestupnì"),
                             command=LookupForm.COMMAND_SORT_COLUMN,
                             args=dict(direction=LookupForm.SORTING_ASCENDENT,
                                       col=col, primary=True)),
                       MItem(_("Øadit sestupnì"),
                             command=LookupForm.COMMAND_SORT_COLUMN,
                             args=dict(direction=LookupForm.SORTING_DESCENDANT,
                                       col=col, primary=True)),)),
                 Menu(_("Dodateèné øazení"),
                      (MItem(_("Øadit vzestupnì"),
                             command=LookupForm.COMMAND_SORT_COLUMN,
                             args=dict(direction=LookupForm.SORTING_ASCENDENT,
                                       col=col)),
                       MItem(_("Øadit sestupnì"),
                             command=LookupForm.COMMAND_SORT_COLUMN,
                             args=dict(direction=LookupForm.SORTING_DESCENDANT,
                                       col=col)),)),
                 MSeparator(),
                 MItem(_("Neøadit podle tohoto sloupce"),
                       command=LookupForm.COMMAND_SORT_COLUMN,
                       args=dict(direction=LookupForm.SORTING_NONE, col=col)),
                 MItem(_("Zru¹it øazení úplnì"),
                       command=LookupForm.COMMAND_SORT_COLUMN,
                       args=dict(direction=LookupForm.SORTING_NONE)),
                 MSeparator(),
                 MItem(_("Seskupit podle tohoto sloupce"),
                       command=ListForm.COMMAND_SET_GROUPING_COLUMN,
                       args=dict(column_id=self._columns[col].id())),
                 MItem(_("Zru¹it seskupování"),
                       command=ListForm.COMMAND_SET_GROUPING_COLUMN,
                       args=dict(column_id=None)),
                 MSeparator(),
                 MItem(_("Skrýt tento sloupec"),
                       command=ListForm.COMMAND_TOGGLE_COLUMN,
                       args=dict(column_id=self._columns[col].id())),
                 Menu(_("Zobrazené sloupce"),
                      [CheckItem(c.label(),
                                 state=lambda a, c=c: c in self._columns,
                                 command=ListForm.COMMAND_TOGGLE_COLUMN,
                                 args=dict(column_id=c.id(), col=col))
                       for c in self._view.fields()] + \
                      [MSeparator(),
                       MItem(_("Vrátit výchozí sloupce"),
                             command=ListForm.COMMAND_RESET_COLUMNS)]),
                 )
        menu = Menu('', items).create(g, self)
        g.PopupMenu(menu)
        menu.Destroy()
        event.Skip()

    def _on_context_menu(self, event):
        # Popup menu pro vybraný øádek gridu
        self._run_callback(self.CALL_USER_INTERACTION)
        row, col = event.GetRow(), event.GetCol()
        self._select_cell(row=row, col=col)
        self.show_context_menu(position=event.GetPosition())
        event.Skip()

    def _on_label_left_down(self, event):
        g = self._grid
        x = event.GetX() + self._scroll_x_offset()
        col = g.XToCol(x)
        x1 = reduce(lambda x, i: x + g.GetColSize(i), range(col), 0)
        x2 = x1 + g.GetColSize(col)
        if x > x1+2 and x < x2-2:
            self._column_to_move = col
        self._mouse_dragged = False
        event.Skip()
        
    def _on_label_left_up(self, event):
        col = self._grid.XToCol(event.GetX() + self._scroll_x_offset())
        if self._column_move_target is not None:
            old_index = self._column_to_move
            new_index = self._column_move_target
            if new_index > old_index:
                new_index -= 1
            if old_index is not None and old_index != new_index:
                c = self._columns[old_index]
                self._update_grid(delete_column=c, insert_column=c,
                                  inserted_column_index=new_index)
        elif not self._mouse_dragged:
            self._run_callback(self.CALL_USER_INTERACTION)
            invoke_command(LookupForm.COMMAND_SORT_COLUMN, col=col,
                           direction=LookupForm.SORTING_CYCLE_DIRECTION)
        self._column_move_target = None
        self._column_to_move = None
        event.GetEventObject().Refresh()
        event.Skip()
        
    def _on_label_mouse_move(self, event):
        def nearest_column(x):
            g = self._grid
            n = g.GetNumberCols()
            pos = 0
            lastwidth = 0
            for col in range(n+1):
                if col <= n:
                    width = g.GetColSize(col)
                else:
                    width = 0
                if pos - lastwidth/2 <= x <= pos + width/2:
                    return col
                lastwidth = width
                pos += width
            return g.GetNumberCols()
        if self._column_to_move is not None:
            x = event.GetX() + self._scroll_x_offset()
            self._column_move_target = nearest_column(x)
            event.GetEventObject().Refresh()
        self._mouse_dragged = True
        event.Skip()

    def _on_label_drag_size(self, event):
        self._remember_column_size(event.GetRowOrCol())
        # Mohli bychom roz¹íøit poslední sloupec, ale jak ho potom zase zú¾it?
        #if config.stretch_tables:
        #    g = self._grid
        #    n = g.GetNumberCols()
        #    w = reduce(lambda x, i: x + g.GetColSize(i), range(n), 0)
        #    x = g.GetSize().x
        #    if w < x:
        #        col = n-1
        #        g.SetColSize(col, g.GetColSize(col) + (x - w))
        #        self._remember_column_size(col)
        event.Skip()

    def _remember_column_size(self, col):
        stored = self._get_state_param('column_width', {})
        stored[self._columns[col].id()] = self._grid.GetColSize(col)
        self._set_state_param('column_width', stored)
        
    def _on_label_paint(self, event):
        def triangle(x, y, r=4, reversed=True):
            # Return polygon coordinates for a triangle.
            if reversed:
                return ((x, y), (x+2*r, y), (x+r, y+r))
            else:
                return ((x+r, y), (x+2*r, y+r), (x, y+r))
        def arrow(x, y, r=5, l=4):
            # Return polygon coordinates for an arrow.
            return ((x, y), (x-r, y-r), (x-r/2, y-r), (x-r/2, y-r-l),
                    (x+r/2, y-r-l), (x+r/2, y-r), (x+r, y-r))
        g = self._grid
        #t = self._table
        dc = wx.PaintDC(g.GetGridColLabelWindow())
        x = - self._scroll_x_offset()
        y = 0
        height = g.GetColLabelSize()
        for col, c in enumerate(self._columns):
            id = c.id()
            width = g.GetColSize(col)
            if col == 0:
                d = 0
            else:
                d = 1
            dc.SetBrush(wx.Brush("GRAY", wx.TRANSPARENT))
            dc.SetTextForeground(wx.BLACK)
            # Draw the rectangle around.
            dc.DrawRectangle(x-d, y, width+d, height)
            # Draw the label itself.
            label = c.column_label()
            while dc.GetTextExtent(label)[0] > width and len(label):
                label = label[:-1] # Don't allow the label to extend the width.
            dc.DrawLabel(label, (x,y,width,height), wx.ALIGN_CENTER|wx.CENTER)
            # Draw the sorting sign.
            pos = position(id, self._lf_sorting, key=lambda x: x[0])
            if pos is not None:
                left = x+width-12
                top = y+3
                r = self._lf_sorting[pos][1] == LookupForm.SORTING_ASCENDENT
                dc.SetBrush(wx.Brush("CORAL", wx.SOLID))
                for i in range(pos):
                    dc.DrawLine(left, top+2*i, left+9, top+2*i)
                dc.DrawPolygon(triangle(left, top+pos*2, reversed=r))
            # Draw the grouping sign.
            if self._lf_grouping == id:
                dc.SetBrush(wx.Brush("CORAL", wx.SOLID))
                dc.DrawCircle(x+5, y+5, 2)
            # Indicate when the column is being moved.
            move_target = self._column_move_target
            if self._column_to_move is not None and move_target is not None:
                if col == move_target:
                    ax = x - d + (col == 0 and 5 or 0)
                elif col == move_target-1 and col == len(self._columns)-1:
                    ax = x + width - 5
                else:
                    ax = None
                if ax is not None:
                    dc.SetBrush(wx.Brush("GREEN", wx.SOLID))
                    dc.DrawPolygon(arrow(ax, height-2))
            x += width

    def _on_wheel(self, event):
        g = self._grid
        delta = event.GetWheelDelta()
        linesPer = event.GetLinesPerAction()
        pxx, pxy = g.GetScrollPixelsPerUnit()
        rot = event.GetWheelRotation()
        lines = rot / delta
        if lines != 0:
            vsx, vsy = g.GetViewStart()
            lines = lines * linesPer
            scrollTo = vsy - pxy / lines
        g.Scroll(-1, scrollTo)    

    def _on_toggle_column(self, column_id, col=None):
        c = find(column_id, self._columns, key=lambda c: c.id())
        if c:
            if len(self._columns) == 1:
                message(_("Poslední sloupec"), beep_=True)
                return
            self._update_grid(delete_column=c)
        else:
            self._update_grid(insert_column=self._view.field(column_id),
                              inserted_column_index=col)

    def _on_reset_columns(self):
        self._update_grid(reset_columns=True)
        
    def show_context_menu(self, position=None):
        if self._table.editing():
            menu = self._edit_menu()
        else:
            menu = self._context_menu()
        g = self._grid
        if menu:
            keymap = global_keymap()
            for item in menu:
                if isinstance(item, MItem):
                    hotkey = keymap.lookup_command(item.command(), item.args())
                    if hotkey is not None:
                        item.set_hotkey(hotkey)
            if position is None:
                row, col = self._current_cell()
                rect = g.CellToRect(row, col)
                pos = (rect.GetX() + rect.GetWidth()/3 ,
                       rect.GetY() + rect.GetHeight()/2 + g.GetColLabelSize())
                position = self._grid.CalcScrolledPosition(pos)
            menu = Menu('', menu).create(g, self)
            g.PopupMenu(menu, position)
            menu.Destroy()

    def show_popup_menu(self):
        self.show_context_menu()

    def show_position(self):
        row = self._current_cell()[0]
        total = self._table.GetNumberRows()
        set_status('list-position', "%d/%d" % (row + 1, total))

    def _show_data_status(self):
        if self._reshuffle_request > self._last_reshuffle_request:
            status = _("Data zmìnìna")
        else:
            status = _("Data ok")
        set_status('data-changed', status)
        
    def on_key_down(self, event, dont_skip=True):
        self._run_callback(self.CALL_USER_INTERACTION)
        if KeyHandler.on_key_down(self, event, dont_skip=dont_skip):
            return True
        def evil_key(event):
            # Tato vìc je tu kvùli eliminaci vstupu do editace políèka
            # libovolnou klávesou.  Není mi znám jiný zpùsob, jak této
            # eliminace dosáhnout.
            # Nelze pou¾ít hasModifiers ani test MetaDown kvùli NumLocku.
            if event.AltDown() or event.ControlDown():
                return False
            code = event.GetKeyCode()
            return code not in(wx.WXK_PRIOR, wx.WXK_NEXT, wx.WXK_LEFT,
                               wx.WXK_RIGHT, wx.WXK_DOWN, wx.WXK_UP,
                               wx.WXK_HOME, wx.WXK_END, wx.WXK_TAB,
                               wx.WXK_ESCAPE)
        if evil_key(event) or \
           (self._grid.IsCellEditControlEnabled() and
            WxKey().is_event_of_key(event, '\t')):
            return False
        else:
            event.Skip()
            return False

    def _is_changed(self):
        editing = self._table.editing()
        return editing and editing.changed

    def can_line_commit(self):
        return self._is_changed()

    def can_line_rollback(self):
        return self._is_changed()
            
    def on_command(self, command, **kwargs):
        # Univerzální pøíkazy
        if command.handler() is not None:
            return self._on_handled_command(command, **kwargs)
        elif command == ListForm.COMMAND_CONTEXT_MENU_ACTION:
            self._on_context_menu_action(**kwargs)
            return True
        elif command == ListForm.COMMAND_COPY_CELL:
            self._on_copy_cell()
            return True
        elif command == ListForm.COMMAND_FILTER_BY_CELL:
            self._filter_by_cell()
            return True
        elif command == ListForm.COMMAND_EDIT:
            self._on_edit()
            return True
        elif command == ListForm.COMMAND_EXPORT_CSV:
            self._on_export_csv()
            return True
        elif command == LookupForm.COMMAND_SORT_COLUMN:
            self._on_sort_column(**kwargs)
            return True
        elif command == ListForm.COMMAND_SET_GROUPING_COLUMN:
            self._refresh(reset={'grouping': kwargs['column_id']})
            return True
        elif command == ListForm.COMMAND_TOGGLE_COLUMN:
            self._on_toggle_column(**kwargs)
            return True
        elif command == ListForm.COMMAND_RESET_COLUMNS:
            self._on_reset_columns(**kwargs)
            return True
        elif command == ListForm.COMMAND_SELECT_CELL:
            self._select_cell(**kwargs)
            return True
        elif command == ListForm.COMMAND_RESIZE_COLUMN:
            self._resize_column(**kwargs)
            return True
        elif command == ListForm.COMMAND_MOVE_COLUMN:
            self._move_column(**kwargs)
            return True
        # Pøíkazy bìhem editace øádku
        elif self._table.editing():
            if command == ListForm.COMMAND_LINE_COMMIT:
                return self._on_line_commit()
            elif command == ListForm.COMMAND_LINE_ROLLBACK:
                return self._on_line_rollback(**kwargs)
            elif command == ListForm.COMMAND_FINISH_EDITING:
                self._finish_editing()
                return True
            # Pøíkazy vztahující se pouze k editaci políèka
            elif self._grid.IsCellEditControlEnabled():
                if command == ListForm.COMMAND_CELL_COMMIT:
                    return self._on_cell_commit()
                elif command == ListForm.COMMAND_CELL_ROLLBACK:
                    return self._on_cell_rollback()
                else:
                    field = self._current_editor.field()
                    if field.on_command(command, **kwargs):
                        return True
        # Pøíkazy mimo editaci
        else:
            if command == ListForm.COMMAND_FIRST_COLUMN:
                self._select_cell(col=0)
            elif command == ListForm.COMMAND_LAST_COLUMN:
                self._select_cell(col=len(self._columns)-1)
            elif command == ListForm.COMMAND_ACTIVATE:
                key = self._current_key()
                self._run_callback(self.CALL_ACTIVATION, (key,), kwargs)
            elif command == ListForm.COMMAND_SHOW_CELL_CODEBOOK:
                self._on_show_cell_codebook()
            elif command == LookupForm.COMMAND_FILTER:
                self._on_filter()
            elif command == ListForm.COMMAND_INCREMENTAL_SEARCH:
                self._on_incremental_search(**kwargs)
            elif command == ListForm.COMMAND_NEW_LINE:
                self._on_insert_line(**kwargs)
            else:
                return super_(ListForm).on_command(self, command, **kwargs)
            return True
        return super_(ListForm).on_command(self, command, **kwargs)
            
    def can_set_grouping(cls, appl, cmd, args):
        f = appl.current_form()
        cid = args.get('column_id')
        if f and isinstance(f, LookupForm):
            grp = f._lf_grouping
            return (cid and cid != grp or grp and not cid)
        else:
            return False
    can_set_grouping = classmethod(can_set_grouping)

    # Metody volané pøímo z callbackových metod
                                   
    def _on_show_cell_codebook(self):
        row, col = self._current_cell()
        column = self._columns[col]
        cb_name = column.codebook()
        if cb_name:
            the_row = self._table.row(row)
            v = the_row[column.id()]
            e = v.type().enumerator()
            run_form(BrowseForm, cb_name, select_row={e.value_column(): v})

    def can_show_cell_codebook(self):
        column = self._columns[self._current_cell()[1]]
        return column.codebook() is not None

    def _on_handled_command(self, command, norefresh=False, **kwargs):
        log(EVENT, 'Vyvolávám u¾ivatelský handler pøíkazu:', command)
        # TODO: Pøíkazy s handlerem by nemìly být vùbec pou¾ívány.  Namísto
        # nich nech» je vyu¾íván pøíkaz COMMAND_CONTEXT_MENU_ACTION,
        # kde se handler definuje jako souèást argumentù a ne jako argument
        # konstruktoru Command.  U¾ivatel zkrátka nemá co vytváøet vlastní
        # instance tøídy Command...  Tato metoda a pøíslu¹ná èást v on_command
        # jsou zde jen kvùli zpìtné kompatibilitì a a¾ se v aplikacích
        # v¹echy u¾ivatelské pøíkazy nahradí, bude mo¾né ji zru¹it.
        handler = command.handler()
        args, kwargs = self._context_menu_handler_args(handler, **kwargs)
        handler(*args, **kwargs)
        if not norefresh:
            self.refresh()
        return True

    def _context_menu_handler_args(self, handler, **kwargs):
        # Zjistíme, jaké má u¾ivatelský handler argumenty.
        import inspect
        allargs, varargs, varkw, defaults = inspect.getargspec(handler)
        if allargs:
            if defaults:
                posargs = len(allargs) - len(defaults)
            else:
                posargs = len(allargs)
        else:
            posargs = 0
        the_row = self.current_row()
        if posargs == 0:
            args = ()
        elif posargs == 1:
            args = (the_row,)
        else:
            args = (self._data, the_row)
        if not varkw:
            if defaults is not None:
                kwnames = allargs[-len(defaults):]
                kwargs = dict([(k,v) for k,v in kwargs.items() if k in kwnames])
            else:
                kwargs = {}
        return args, kwargs
    
    def _on_context_menu_action(self, handler=None, enabled=None, **kwargs):
        log(EVENT, 'Vyvolávám u¾ivatelský handler akce kontextového menu.')
        if not callable(handler):
            raise ProgramError("Nepøípustný handler akce konetxtového menu:",
                               handler)
        args, kwargs = self._context_menu_handler_args(handler, **kwargs)
        handler(*args, **kwargs)
        #if not norefresh:
        self.refresh()
        return True
    
    def can_context_menu_action(self, handler=None, enabled=None, **kwargs):
        if enabled:
            args, kwargs = self._context_menu_handler_args(enabled, **kwargs)
            return enabled(*args, **kwargs)
        else:
            return True

    def _on_incremental_search(self, full=False):
        row, col = self._current_cell()
        column = self._columns[col]
        if not isinstance(column.type(self._data), pytis.data.String):
            message(_("V tomto sloupci nelze vyhledávat inkrementálnì"),
                    beep_=True)
            return
        search_field = _grid.IncrementalSearch(self, full)
        search_field.run()

    def _on_filter(self, show_dialog=True):
        row, col = self._current_cell()
        super_(ListForm)._on_filter(self, row=self._table.row(row),
                                    col=col, show_dialog=show_dialog)

    def _on_copy_cell(self):
        row, col = self._current_cell()
        cid = self._columns[col].id()
        clptext = self._table.row(row).format(cid)
        # set_clipboard_text(clptext)
        # TODO: wxClipboard nefunguje, jak má, tak to vyøe¹íme
        #       hackem, kdy vyu¾ijeme toho, ¾e wxTextCtrl.Copy()
        #       dìlá to, co má.
        tc = wx.TextCtrl(self, -1, clptext)
        tc.SetSelection(0,len(clptext))
        tc.Copy()
        tc.Destroy()

    def _on_export_csv(self):
        log(EVENT, 'Vyvolání CSV exportu')
        data = self._data
        # Kontrola poètu øádkù
        number_rows = self._table.GetNumberRows()
        if number_rows == 0:
            msg = _("Tabulka neobsahuje ¾ádné øádky! Export nebude proveden.")
            run_dialog(Warning, msg)
            return
        # Seznam sloupcù
        column_list = []
        for column in self._columns:
            column_list.append((column.id(), column.type(data)))
        allowed = True
        # Kontrola práv        
        for cid, ctype in column_list:
            if not data.accessible(cid, pytis.data.Permission.EXPORT):
                allowed = False
                break
        if not allowed:
            msg = _("Nemáte právo exportu k této tabulce.\n")
            msg = msg + _("Export nebude proveden.")
            run_dialog(Warning, msg)
            return            
        export_dir = config.export_directory
        export_encoding = config.export_encoding
        db_encoding = config.db_encoding
        try:
            u"test".encode(export_encoding)
        except:
            msg = _("Kódování %s není podporováno.\n" % export_encoding)
            msg = msg + _("Export se provede bez pøekódování.")
            export_encoding = None
            run_dialog(Error, msg)
        try:
            u"test".encode(db_encoding)
        except:
            msg = _("Kódování %s není podporováno.\n" % db_encoding)
            msg = msg + _("Export se neprovede.")
            run_dialog(Error, msg)
            return
        filename = pytis.form.run_dialog(pytis.form.FileDialog,
                                       title="Zadat exportní soubor",
                                       dir=export_dir, file='export.txt',
                                       mode='SAVE',
                                       wildcards=("Soubory TXT (*.txt)",
                                                  "*.txt",
                                                  "Soubory CSV (*.csv)",
                                                  "*.csv"))
        if not filename:
            return
        try:       
            export_file = open(filename,'w')
        except:
            msg = _("Nepodaøilo se otevøít soubor " + filename + \
                    " pro zápis!\n")
            run_dialog(Error, msg)
            return
        def _process_table(update):
            # Export labelù
            for column in self._columns:
                export_file.write(column.label()+'\t')
            export_file.write('\n')
            for r in range(0,number_rows):
                if not update(int(float(r)/number_rows*100)):
                    break
                for cid, ctype in column_list:
                    if isinstance(ctype, pytis.data.Float):
                        s = self._table.row(r)[cid].export(locale_format=False)
                    else:
                        s = self._table.row(r)[cid].export()
                    if export_encoding and export_encoding != db_encoding:
                        if not is_unicode(s):
                            s = unicode(s, db_encoding)
                        s = s.encode(export_encoding)
                    export_file.write(';'.join(s.split('\n'))+'\t')
                export_file.write('\n')
            export_file.close()
        pytis.form.run_dialog(pytis.form.ProgressDialog, _process_table)       
        
    def _on_edit(self):
        if not self.editable:
            log(EVENT, 'Pokus o editaci needitovatelné tabulky')
            return False
        table = self._table
        if not table.editing():
            if not self._lock_record(self._current_key()):
                return False
            table.edit_row(self._current_cell()[0])
            self._update_selection_colors()
        if not self._edit_cell():
            self._on_line_rollback()
        return True

    def _on_insert_line(self, before=False, copy=False):
        """Vlo¾ nový øádek do seznamu.

        Argumenty:

          before -- je-li pravda, nový øádek se vlo¾í pøed aktuální øádek, jinak
            se vlo¾í za aktuální øádek
          copy -- je-li pravda a seznam není prázdný, obsahem nového øádku bude
            obsah aktuálního øádku, v opaèném pøípadì bude nový øádek prázdný

        Vlo¾ení nového øádku do seznamu je mo¾né jen tehdy, pokud není zrovna
        ¾ádný øádek editován, a» u¾ nový nebo stávající.  Pøi pokusu o vlo¾ení
        nového øádku bìhem editace jiného øádku je chování metody nedefinováno.

        Vlo¾ení nového øádku mù¾e být také zakázáno pro konkrétní formuláø v
        jeho specifikaci (viz argument 'enable_inline_insert' konstruktoru
        tøídy 'ViewSpec').
        
        Po vlo¾ení nového øádku seznam automaticky pøejde do re¾imu editace
        tohoto øádku a spustí editaci první editovatelné buòky øádku.

        """
        row = self._current_cell()[0]
        log(EVENT, 'Vlo¾ení nového øádku:', (row, before, copy))
        if not self._data.accessible(None, pytis.data.Permission.INSERT):
            message('Nemáte pøístupová práva pro vkládání záznamù do této ' + \
                    'tabulky!', beep_=True)
            return False
        if not self.editable:
            message('Needitovatelná tabulka!', beep_=True)
            return False
        if not self._enable_inline_insert:
            message('Není mo¾né vkládat øádky v in-line editaci. ' +
                    'Pou¾ijte editaèní formuláø.', beep_=True)
            return False
        table = self._table
        if table.editing():
            log(EVENT, 'Pokus o vlo¾ení nového øádku bìhem editace')
            return False
        self._last_insert_copy = copy
        oldg = self._grid
        oldempty = (oldg.GetNumberRows() == 0)
        if not copy or oldempty:
            the_row = None
        else:
            the_row = table.row(row)
            # TODO: mo¾ná pùjde vyøe¹it èistìji
            # Jde o to vytvoøit kopii øádku, ale klíè nekopírovat.
            prefill = {}
            keys = [c.id() for c in the_row.data().key()]
            for k in the_row.keys():
                if k not in keys:
#                    prefill[k] = the_row[k].value()
                    prefill[k] = the_row[k]
            fields = the_row.fields()
            data = the_row.data()
            the_row = PresentedRow(fields, data, None, prefill=prefill,
                                   new=True)
            for k in the_row.keys():
                the_row[k]
        if not before and not oldempty:
            row = row + 1
        if row == -1:
            row = 0
        self._update_grid(inserted_row_number=row, inserted_row=the_row)
        self._select_cell(row=row, col=0, invoke_callback=False)
        if not self._is_editable_cell(row, 0) \
               and not self._find_next_editable_cell():
            log(EVENT, '®ádný sloupec není editovatelný')
            return False
        self._edit_cell()
        self._update_selection_colors()
        log(EVENT, 'Øádek vlo¾en')
        return True

    def _on_line_commit(self):
        # Zde zále¾í na návratové hodnotì, proto¾e ji vyu¾ívá _on_cell_commit.
        log(EVENT, 'Pokus o ulo¾ení øádku seznamu do databáze')
        # Vyta¾ení nových dat
        table = self._table
        editing = table.editing()
        if not editing:
            return False
        row = editing.row
        the_row = editing.the_row
        # Ovìøení integrity záznamu (funkce check).
        failed_id = self._check_record(the_row)
        if failed_id:
            col = find(failed_id, self._columns, key=lambda c: c.id())
            if col is not None:
                i = self._columns.index(col)
                self._select_cell(row=row, col=i, invoke_callback=False)
                self._edit_cell()
            return True
        # Urèení operace a klíèe
        rdata = self._record_data(the_row)
        kc = [c.id() for c in self._data.key()]
        if editing.new:
            if row > 0:
                after = table.row(row-1).row().columns(kc)
                before = None
            elif row < table.GetNumberRows() - 1:
                after = None
                before = table.row(row+1).row().columns(kc)
            else:
                after = before = None
            op = (self._data.insert, (rdata,), dict(after=after, before=before))
        else:
            key = editing.orig_content.row().columns(kc)
            op = (self._data.update, (key, rdata))
        # Provedení operace
        success, result = db_operation(op)
        if success and result[1]:
            table.edit_row(None)
            self._unlock_record()
            message('Øádek ulo¾en do databáze', ACTION)
            self.refresh()
            self._run_callback(self.CALL_MODIFICATION)
            on_line_commit = self._view.on_line_commit()
            if on_line_commit is not None:
                on_line_commit(the_row)
            self.focus()
        elif success:
            log(EVENT, 'Zamítnuto pro chybu klíèe')
            if editing.new:
                msg = _("Øádek s tímto klíèem ji¾ existuje nebo zmìna "
                        "sousedního øádku")
            else:
                msg = _("Øádek s tímto klíèem ji¾ existuje nebo pùvodní "
                        "øádek ji¾ neexistuje")
            run_dialog(Warning, msg)
            return False
        else:
            log(EVENT, 'Chyba databázové operace')
            return False
        return True

    def _on_line_rollback(self, soft=False):
        log(EVENT, 'Zru¹ení editace øádku')
        editing = self._table.editing()
        if not editing:
            return False
        if soft and editing.changed:
            return True
        self._unlock_record()
        row = editing.row
        if editing.new:
            self._update_grid()
        else:
            self._table.edit_row(None)
            self._update_selection_colors()
            # Tento SelectRow je zde nutný pro vynucení pøekreslení øádku se
            # staronovými hodnotami.
            self._grid.SelectRow(row)
        self._select_cell(row=row, invoke_callback=False)
        self.refresh()
        return True

    def _on_cell_commit(self):
        row, col = self._current_cell()
        log(EVENT, 'Odeslání obsahu políèka gridu', (row, col))
        self._grid.DisableCellEditControl()
        editing = self._table.editing()
        if not editing:
            return True
        if editing.valid:
            if not self._find_next_editable_cell():
                if editing.new:
                    q = _("Ulo¾it øádek?")
                    if run_dialog(Question, q, True):
                        log(EVENT, 'Kladná odpovìï na dotaz o ulo¾ení øádku')
                        if self._on_line_commit():
                            # TODO: voláním následující metody v tìle této
                            # metody, která o¹etøuje pøíkaz, dojde k
                            # zablokování zpracování pøíkazù v rámci jejího
                            # zpracování.  Ne¾ bude následující volání opìt
                            # odkomentováno, je tøeba zajistit neblokující
                            # zpracování pøíkazù...
                            # self._on_insert_line(copy=self._last_insert_copy)
                            pass
                        return True
                    else:
                        log(EVENT, 'Záporná odpovìï na dotaz o ulo¾ení øádku')
                self._grid.SetGridCursor(row, 0)
        if not editing.valid or editing.new:
            log(EVENT, 'Návrat do editace políèka')
            self._edit_cell()
        return True
        
    def _on_cell_rollback(self):
        log(EVENT, 'Opu¹tìní políèka gridu beze zmìny hodnoty')
        self._current_editor.Reset()
        self._grid.DisableCellEditControl()
        self._current_editor = None
        return True

    def _on_delete_record(self, key):
        if not self.editable:
            message('Needitovatelná tabulka!', beep_=True)
            return False
        def blocked_code():
            key = self._current_key()
            deleted = super(ListForm, self)._on_delete_record(key)
            self._table.edit_row(None)
            return deleted
        if block_refresh(blocked_code):
            r = self._current_cell()[0]
            n = self._table.GetNumberRows()
            if r < n - 1:
                self._select_cell(row=r+1)
            elif r > 0:
                self._select_cell(row=r-1)
            # Udìláme radìji refresh celé aplikace, proto¾e jinak se
            # nerefreshne horní formuláø po vymazání záznamu ze sideformu.
            refresh()

    # Veøejné metody

    def is_edited(self):
        """Vra» pravdu, právì kdy¾ je List ve stavu øádkové editace."""
        return self._table.editing()

    def exit_check(self):
        """Proveï kontrolu ukonèení editace øádku pøed opu¹tìním seznamu.

        Metoda nic nevrací, pouze sama provede, co je potøeba.

        """
        editing = self._table.editing()
        if editing:
            log(EVENT, 'Pokus o odchod z øádkového formuláøe bìhem editace')
            if editing.changed and  \
                   run_dialog(Question, _("Ulo¾it zeditovaný øádek?"), True):
                log(EVENT, 'Vy¾ádáno ulo¾ení')
                self._on_line_commit()
            else:
                log(EVENT, 'Ulo¾ení zamítnuto')
                self._on_line_rollback()

    def _total_height(self):
        g = self._grid
        height = g.GetColLabelSize()
        rows = self._grid.GetNumberRows()
        if rows:
            height += rows * g.GetRowSize(0)
        if self._title_bar:
            height += self._title_bar.GetSize().height
        return height

    def _find_row_by_number(self, row_number):
        # Nutno pøedefinovat, proto¾e metoda rodiè. tøídy nám rozhodí kurzor.
        # Krom toho je toto rychlej¹í...
        return self._table.row(row_number).row()

    def _find_row_by_values(self, cols, values):
        # Nutno pøedefinovat, proto¾e metoda rodiè. tøídy nám rozhodí kurzor.
        cols = xtuple(cols)
        values = xtuple(values)
        assert len(cols) == len(values)
        condition = apply(pytis.data.AND, map(pytis.data.EQ, cols, values))
        data = self._data
        data.rewind()
        success, result = db_operation(lambda: data.search(condition))
        if not success:
            row = 0
        elif result == 0:
            row = 0
        else:
            row = result - 1
        prow = self._table.row(row)
        if prow:
            return prow.row()
        else:
            return None

    def select_row(self, position, quiet=False):
        # Bìhem editace mù¾e `position' obsahovat nevyhledatelná data.
        if position is not None and self._table.editing():
            position = self._table.editing().row
        if isinstance(position, types.IntType):
            # Pro èíslo voláme rovnou _select_cell a nezdr¾ujeme se pøevodem na
            # row a zpìt, který probíhá v rodièovské metodì...
            self._select_cell(row=position)
        else:
            super(ListForm, self).select_row(position, quiet=quiet)
    
    def _select_row(self, row):
        if row is None:
            row_number = -1
        else:
            row_number = self._get_row_number(row)
        self._select_cell(row=row_number)


    # Veøejné metody
        
    def _refresh(self, reset=None, when=None):
        """Aktualizuj data seznamu z datového zdroje.

        Pøekresli celý seznam v okam¾iku daném argumentem 'when' se zachováním
        parametrù dle argumentu 'reset'.

        Argumenty:

          reset -- urèuje, které parametry zobrazení mají být zachovány a které
            zmìnìny.  Hodnotou je buï 'None', nebo dictionary.  Je-li hodnotou
            'None', zùstane zachována filtrovací podmínka, tøídìní i vybraný
            øádek (vzhledem k jeho obsahu, ne poøadí), je-li to mo¾né.  Je-li
            hodnotou prázdné dictionary, jsou naopak v¹echny tyto parametry
            resetovány na své poèáteèní hodnoty.  Jinak jsou resetovány právì
            ty parametry, pro nì¾ v dictionary existuje klíè (jeden z øetìzcù
            'sorting', 'grouping', 'condition', 'position' a 'filter_flag'),
            a to na hodnotou z dictionary pro daný klíè.  Parametr
            'filter_flag' udává, zda má být zobrazena indikace filtru.

          when -- urèuje, zda a kdy má být aktualizace provedena, musí to být
            jedna z 'DOIT_*' konstant tøídy.  Implicitní hodnota je
            'DOIT_AFTEREDIT', je-li 'reset' 'None', 'DOIT_IMMEDIATELY' jinak.

        Vrací: Pravdu, právì kdy¾ byla aktualizace provedena.

        """
        assert when in (None,           # to je pouze interní hodnota
                        self.DOIT_IMMEDIATELY, self.DOIT_AFTEREDIT,
                        self.DOIT_IFNEEDED), \
                        ("Invalid argument 'when'", when)
        assert reset is None or type(reset) == type({}), reset
        if when is None:
            if reset is None:
                when = self.DOIT_AFTEREDIT
            else:
                when = self.DOIT_IMMEDIATELY
        if reset == None:
            reset = {}
        elif reset == {}:
            reset = {'sorting': self._lf_initial_sorting,
                     'grouping': self._lf_initial_grouping,
                     'condition': self._lf_initial_condition,
                     'position': self._initial_position,
                     'filter_flag': False}
        # Jdeme na to
        if __debug__: log(DEBUG, 'Po¾adavek na refresh:', (reset, when))
        if when is self.DOIT_IFNEEDED:
            if self._reshuffle_request == self._last_reshuffle_request or \
                   self._reshuffle_request > time.time():
                if __debug__: log(DEBUG, 'Refresh není tøeba provádìt nyní')
                return False
        if when is self.DOIT_IMMEDIATELY:
            QUESTION = _("Zru¹it zmìny záznamu a aktualizovat seznam?")
            delay = not self._finish_editing(question=QUESTION)
        else:
            delay = (self._table.editing() is not None) # nechceme dr¾et info
        if delay:
            if __debug__: log(DEBUG, 'Refresh odlo¾en do ukonèení editace')
            return False
        # Refresh nyní bude skuteènì proveden
        for k, v in reset.items():
            if k == 'condition':
                self._lf_condition = v
            elif k == 'sorting':
                self._lf_sorting = v
            elif k == 'grouping':
                self._lf_grouping = v
            elif k == 'position':
                self._position = v
            elif k == 'filter_flag':
                self._lf_indicate_filter = v
            else:
                raise ProgramError('Invalid refresh parameter', k)
        key = self._current_key()
        row = max(0, self._current_cell()[0])
        self._last_reshuffle_request = self._reshuffle_request = time.time()
        
        self._update_grid(data_init=True)
        
        if key is not None:
            self.select_row(key, quiet=True)
            # Pokud se nepodaøilo nastavit pozici na pøedchozí klíè,
            # pokusíme se nastavit pozici na pøedchozí èíslo øádku v gridu.
            if self._current_key() != key and \
                   row < self._table.GetNumberRows() and row >= 0:
                self._select_cell(row=row)
        else:
            self._select_cell(row=row)
        self._show_data_status()
        return True

    def status_fields(self):
        # TODO: zatím je podoba statusbaru urèena specifikací, ale bylo by
        # rozumné to celé pøedìlat, aby se statusbar dynamicky mìnil podle
        # aktuálního formuláøe (s vyu¾itím této metody).
        return (('list-position', 7),)

    def _update_colors(self):
        self._update_selection_colors()
        self._update_label_colors()
        if config.cell_highlight_color is not None:
            self._grid.SetCellHighlightColour(config.cell_highlight_color)
        if config.grid_line_color is not None:
            self._grid.SetGridLineColour(config.grid_line_color)

    def _total_width(self):
        total = 0
        for c in self._columns:
            total += self._column_width(c)
        return total

    def _resize_columns(self, size=None):
        g = self._grid
        if size is None:
            size = g.GetSize()
        width = size.width
        height = size.height
        if height < self._total_height():
            width = width - wx.SystemSettings.GetMetric(wx.SYS_VSCROLL_X) - 1
        total_width = self._total_width()
        if width > total_width:
            coef = float(width) / total_width
        else:
            coef = 1
        total = 0
        last = None
        # Pøenastav ¹íøky sloupcù
        for i, c in enumerate(self._columns):
            w = self._column_width(c)
            if not c.fixed() and config.stretch_tables:
                w = int(w*coef)
                last = i
            g.SetColSize(i, w)
            total += w
        if coef != 1 and total != width and last is not None:
            g.SetColSize(last, g.GetColSize(last) + (width - total))

    # wx metody

    def _on_size(self, event):
        size = event.GetSize()
        if size.width != self._grid.GetSize().width:
            self._resize_columns(size)
        event.Skip()
            
    def Close(self):
        self._data.remove_callback_on_change(self.on_data_change)
        try:
            self._data.close()
        except pytis.data.DBException:
            pass
        # Musíme ruènì zru¹it editory, jinak se doèkáme segmentation fault.
        for e in self._editors:
            if e:
                e.close()
        # Musíme tabulce zru¹it datový objekt, proto¾e jinak do nìj bude ¹ahat
        # i po kompletním uzavøení starého gridu (!!) a rozhodí nám tak data
        # v novém gridu.
        self._table.close()    
        return super_(ListForm).Close(self)

    def Show(self, show):
        if not show:
            self.exit_check()
        return super_(ListForm).Show(self, show)
    
    # Ostatní veøejné metody

    def focus(self):
        super_(ListForm).focus(self)
        self.show_position()
        self._show_data_status()
        self._update_selection_colors()
        self._grid.SetFocus()
        
    def defocus(self):
        super_(ListForm).defocus(self)
        self._update_selection_colors()



class CodebookForm(ListForm, PopupForm, KeyHandler):
    """Formuláø pro zobrazení výbìrového seznamu (èíselníku).

    Výbìrový seznam zobrazuje øádky dat, z nich¾ u¾ivatel nìkterý øádek
    vybere.  U¾ivatel kromì výbìru a listování nemù¾e s øádky nijak
    manipulovat.

    Formuláø je zobrazen jako modální okno pomocí metody 'run()', která skonèí
    po výbìru polo¾ky a vrátí instanci PresentedRow pro vybraný øádek.  Pokud
    byl formuláø ukonèen jinak ne¾ výbìrem záznamu, je vrácena hodnota 'None'.

    """

    _DEFAULT_WINDOW_HEIGHT = 500

    def __init__(self, parent, *args, **kwargs):
        parent = self._popup_frame(parent)
        super_(CodebookForm).__init__(self, parent, *args, **kwargs)
        h = min(self._DEFAULT_WINDOW_HEIGHT, self._total_height()+50)
        self.SetSize((self._total_width()+30, h))
        wx_callback(wx.grid.EVT_GRID_CELL_LEFT_DCLICK, self._grid,
                    lambda e: self._on_activation())

    def _init_attributes(self, condition=None, begin_search=None, **kwargs):
        """Zpracuj klíèové argumenty konstruktoru a inicializuj atributy.

        Argumenty:

          condition -- podmínka filtrující øádky èíselníku jako instance
            'pytis.data.Operator'.
          begin_search -- Pokud není None, bude po otevøení formuláøe
            automaticky nastartováno inkrementální vyhledávání. Pokud
            je hodnota øetìzec, je chápán jako identifikátor
            sloupce, ve kterém se má provádìt vyhledávání. Není-li ho
            hodnota øetìzec, nebo neodpovídá-li ¾ádnému sloupci,
            je vyhledávání provádìno automaticky nad sloupeèkem s
            primárním tøídìním.
            
        """
        try:
            self._cb_spec = self._resolver.get(self._name, 'cb_spec')
        except ResolverError:
            self._cb_spec = CodebookSpec()
        super_(CodebookForm)._init_attributes(self, **kwargs)
        self._begin_search = begin_search
        if condition is not None:
            condition = pytis.data.AND(self._lf_initial_condition, condition)
            self._lf_initial_condition = condition
          
    def _on_idle(self, event):
        ListForm._on_idle(self, event)
        if not hasattr(self, '_focus_forced_to_grid'):
            self._grid.SetFocus()
            self._focus_forced_to_grid = True
        if self._begin_search:
            begin_search = self._begin_search
            self._begin_search = None
            if isinstance(begin_search, types.StringType):
                col_id = begin_search
            elif self._lf_sorting is not None:
                col_id = self._lf_sorting[0][0]
            else:
                message(_("Nelze zaèít inkrementální vyhledávání. "
                          "Èíselník neobsahuje ¾ádný setøídìný sloupec!"),
                        beep_=True)
            col = find(col_id, self._columns, key=lambda c:c.id())
            if col is not None:
                self._select_cell(row=0, col=self._columns.index(col))
                self._on_incremental_search(full=False)
            else:
                log(OPERATIONAL, "Invalid search column:", col_id)

    def _default_columns(self):
        return self._cb_spec.columns() \
               or super(CodebookForm, self)._default_columns()

    def _default_sorting(self):
        sorting = self._cb_spec.sorting()
        if sorting is not None:
            return sorting
        else:
            return super(CodebookForm, self)._default_sorting()
        
    def _context_menu(self):
        return (MItem(_("Vybrat"),
                      command = ListForm.COMMAND_ACTIVATE),
                )

    def on_command(self, command, **kwargs):
        if command == Application.COMMAND_LEAVE_FORM:
            self._leave_form()
            return True
        return super_(CodebookForm).on_command(self, command, **kwargs)

    def _on_activation(self, key=None, alternate=False):
        """Nastav návratovou hodnotu a ukonèi modální dialog."""
        self._result = self.current_row()
        self._parent.EndModal(1)
        return True

    
class BrowseForm(ListForm):
    """Formuláø pro prohlí¾ení dat s mo¾ností editace."""

    class _PrintResolver (pytis.output.OutputResolver):
        P_NAME = 'P_NAME'
        class _Spec:
            def body(self, resolver, variant=None):
                table_id = resolver.p(BrowseForm._PrintResolver.P_NAME)
                result = pytis.output.data_table(resolver, table_id)
                return result
            def doc_header(self, resolver, variant=None):
                return None
            def doc_footer(self, resolver, variant=None):
                return None
            def coding(self, resolver, variant=None):
                if wx.Font_GetDefaultEncoding() == \
                   wx.FONTENCODING_ISO8859_2:
                    result = pytis.output.Coding.LATIN2
                else:
                    result = pytis.output.Coding.ASCII
                return result
        def _get_module(self, module_name):
            try:
                result = pytis.output.OutputResolver._get_module(self,
                                                                 module_name)
            except ResolverModuleError:
                result = self._Spec()
            return result
        
    def _formatter_parameters(self):
        name = self._name
        return {(name+'/'+pytis.output.P_CONDITION):
                pytis.data.AND(self._lf_initial_condition, self._lf_condition),
                (name+'/'+pytis.output.P_SORTING):
                self._lf_translated_sorting(),
                (name+'/'+pytis.output.P_KEY):
                self._current_key(),
                (name+'/'+pytis.output.P_ROW):
                copy.copy(self._table.row(self._current_cell()[0])),
                (name+'/'+pytis.output.P_DATA):
                copy.copy(self._data)
                }

    def _context_menu(self):
        # Sestav specifikaci kontextového menu
        menu = super_(BrowseForm)._context_menu(self) + (
            MItem(_("Editovat buòku"),
                  command=ListForm.COMMAND_EDIT),
            MItem(_("Filtrovat podle buòky"),
                  command=ListForm.COMMAND_FILTER_BY_CELL),
            MItem(_("Zkopírovat obsah buòky"),
                  command=ListForm.COMMAND_COPY_CELL),
            MSeparator(),
            MItem(_("Editovat záznam"),
                  command=BrowseForm.COMMAND_EDIT_RECORD),
            MItem(_("Smazat záznam"),
                  command=RecordForm.COMMAND_DELETE_RECORD),
            MItem(_("Náhled"),
                  command=ListForm.COMMAND_ACTIVATE),
            MItem(_("Náhled v druhém formuláøi"),
                  command=ListForm.COMMAND_ACTIVATE, args=dict(alternate=True)),
            MItem(_("Zobrazit související èíselník"),
                  command=ListForm.COMMAND_SHOW_CELL_CODEBOOK),
            )
        custom_menu = self._view.popup_menu()
        if custom_menu:
            menu += (MSeparator(),) + custom_menu
        return menu

    def _on_import_interactive(self):
        if not self._data.accessible(None, pytis.data.Permission.INSERT):
            msg = _("Nemáte práva pro vkládání záznamù do této tabulky.")
            message(msg, beep_=True)
            return False
        msg = _("Nejprve vyberte soubor obsahující importovaná data. "
                "Poté budete moci zkontrolovat a potvrdit ka¾dý záznam.\n\n"
                "*Formát vstupního souboru:*\n\n"
                "Ka¾dý øádek obsahuje seznam hodnot oddìlených zvoleným "
                "znakem, nebo skupinou znakù (vyplòte ní¾e). "
                "Tabelátor zapi¹te jako ='\\t'=.\n\n"
                "První øádek obsahuje identifikátory sloupcù a urèuje tedy "
                "význam a poøadí hodnot v následujících (datových) øádcích.\n\n"
                "Identifikátory jednotlivých sloupcù jsou následující:\n\n" + \
                "\n".join(["|*%s*|=%s=|" % \
                           (c.column_label(), c.id().replace('_', '!_'))
                           for c in self._columns]))
        separator = run_dialog(InputDialog, 
                               title=_("Hromadné vkládání dat"),
                               report=msg, report_format=TextFormat.WIKI,
                               prompt="Oddìlovaè", value='|')
        if not separator:
            if separator is not None:
                message(_("Nebyl zadán oddìlovaè."), beep_=True)
            return False
        separator.replace('\\t', '\t')
        while 1:
            filename = run_dialog(FileDialog)
            if filename is None:
                message(_("Nebyl zadán soubor.  Proces ukonèen."), beep_=True)
                return False
            try:
                f = open(filename)
            except IOError, e:
                msg = _("Nebylo mo¾no otevøít soubor '%s': %s")
                run_dialog(Error, msg % (filename, str(e)))
                continue
            break
        try:
            columns = []
            for key in f.readline().split(separator):
                col = find(key.strip(), self._fields, key=lambda c: c.id())
                if col:
                    columns.append(col)
                else:
                    msg = _("Chybný identifikátor sloupce: %s")
                    run_dialog(Error, msg % key.strip())
                    return False
            i = 0 # aktuální èíslo øádku dat (nepoèítaje záhlaví)
            n = 0 # poèet skuteènì vlo¾ených záznamù
            prefill = self.prefill()
            for line in f:
                i += 1
                values = line.rstrip('\r\n').split(separator)
                if len(values) != len(columns):
                    msg = _("Chyba na øádku %d: "
                            "Poèet hodnot neodpovídá poètu sloupcù.\n"
                            "Chcete pøesto pokraèovat (dal¹ím záznamem)?")
                    if run_dialog(Question, msg % i+1,
                                  title=_("Chyba vstupních dat"),
                                  icon=Question.ICON_ERROR):
                        continue
                    else:
                        break
                data = prefill and copy.copy(prefill) or {}
                for col, val in zip(columns, values):
                    type = col.type(self._data)
                    value, error = type.validate(val)
                    if error:
                        msg = _("Chybná hodnota sloupce '%s' na øádku %d: %s\n"
                                "Chcete pøesto záznam vlo¾it?")
                        msg = msg % (col.id(), i+1, error.message())
                        if not run_dialog(Question, msg,
                                          title=_("Chyba vstupních dat"),
                                          icon=Question.ICON_ERROR):
                            break
                    data[col.id()] = value
                else:
                    result = new_record(self._name, prefill=data)
                    if result:
                        n += 1
                    else:
                        msg = _("Je¹tì nebyly zpracovány v¹echny øádky "
                                "vstupních dat.\n"
                                "Chcete pokraèovat ve vkládání?")
                        if not run_dialog(Question, msg):
                            break
        finally:
            f.close()
        run_dialog(Message, _("%d/%d záznamù bylo vlo¾eno.") % (n, i),
                   title=_("Hromadné vkládání dat dokonèeno"))

    def _on_print_(self, spec_path):
        log(EVENT, 'Vyvolání tiskového formuláøe')
        name = self._name
        if not spec_path:
            try:
                spec_paths = self._resolver.get(name, 'print_spec')
            except ResolverError:
                spec_paths = None
            if spec_paths:
                spec_path = spec_paths[0][1]
            else:
                spec_path = os.path.join('output', name)
        P = self._PrintResolver
        parameters = self._formatter_parameters()
        parameters.update({P.P_NAME: name})
        print_resolver = P(self._resolver, parameters=parameters)
        resolvers = (print_resolver,)
        formatter = pytis.output.Formatter(resolvers, spec_path)
        run_form(PrintForm, name, formatter=formatter)

    def on_command(self, command, **kwargs):
        if command == Form.COMMAND_PRINT and \
               (not kwargs.has_key('form') or kwargs['form'] is self):
            self._on_print_(kwargs.get('print_spec_path'))
        elif command == BrowseForm.COMMAND_IMPORT_INTERACTIVE:
            self._on_import_interactive()
        else:
            return super_(BrowseForm).on_command(self, command, **kwargs)
        return True


class FilteredBrowseForm(BrowseForm):
    """Prohlí¾ecí formuláø s filtrovaným obsahem.

    Oproti obyèejnému prohlí¾ecímu formuláøi zobrazuje filtrovaný formuláø
    pouze øádky splòující podmínku zadanou v konstruktoru, pøípadnì
    kombinovanou se zadaným datovým klíèem.

    """

    def __init__(self, *args, **kwargs):
        super_(FilteredBrowseForm).__init__(self, *args, **kwargs)
        self._init_filter()
    
    def _init_attributes(self, condition=None, **kwargs):
        """Zpracuj klíèové argumenty konstruktoru a inicializuj atributy.
        
        Argumenty:

          condition -- hodnotou je podmínkový výraz pro datové dotazy, tak jak
            je definovaný v metodì 'pytis.data.Data.select()'.  Tento výraz mù¾e
            být i funkcí jednoho argumentu vracející pøíslu¹ný podmínkový
            výraz, pøedaným argumentem je dictionary id sloupcù (strings) a
            jejich hodnot (instancí tøídy 'pytis.data.Value').

        Má-li podmínka podobu statického operátoru, je filtrování provedeno
        ihned a nelze je zmìnit.  Má-li naopak podmínka podobu funkce, jsou
        zobrazena v¹echna data a¾ do prvního zavolání metody `filter()';
        následnými voláními této funkce pak lze výbìr upravovat.

        """
        super_(FilteredBrowseForm)._init_attributes(self, **kwargs)
        assert callable(condition) or isinstance(condition, pytis.data.Operator)
        self._condition = condition

    def _init_filter(self):
        self.filter()

    def filter(self, data=None):
        """Filtruj data dle podmínky z konstruktoru a 'data'.

        Argumenty:

          data -- 'None' nebo dictionary, jeho¾ klíèe jsou ids sloupcù
            (strings) a hodnoty jim pøíslu¹né hodnoty (instance tøídy
            'pytis.data.Value').  Jestli¾e je dictionary prázdné, budou
            odfiltrovány v¹echny záznamy; jestli¾e je 'None', budou naopak
            v¹echny záznamy zobrazeny.  Tento volitelný argument není nutno
            v zápisu volání funkce klíèovat.

        Je-li podmínka zadaná v konstruktoru statickým operátorem, metoda pouze
        zavolá 'refresh()' na obalený list.  Je-li naopak podmínka zadaná
        v konstruktoru funkcí, je provedeno pøefiltrování v závislosti na
        argumentu 'data' -- je-li 'None', tak jsou zobrazena v¹echna data bez
        omezení výbìru, jinak jsou zobrazena data dle podmínky vrácené voláním
        podmínkové funkce.

        """
        #log(EVENT, 'Filtrace obsahu formuláøe:', (self._name, data))
        if data is None:
            condition = None
        elif data == {}:
            condition = pytis.data.OR()
            data = None
        elif callable(self._condition):
            condition = self._condition(data)
        else:
            condition = self._condition
        self._lf_initial_condition = condition
        self._refresh(reset={'condition': None})


class SideBrowseForm(FilteredBrowseForm):
    """Formuláø zobrazující podmno¾nu øádkù závislých na jiném øádku dat.

    Data tohoto formuláøe jsou filtrována v závislosti na aktuálním øádku v
    jiném formuláøi.
    
    Filtrovací podmínka je vytváøena automaticky jako ekvivalence hodnot
    vazebních sloupcù v hlavním a vedlej¹ím formuláøi.  Identifikátory
    pøíslu¹ných sloupcù jsou dány argumenty `binding_column' a
    `sibling_binding_column'.

    """

    def _init_attributes(self, sibling_name, sibling_row,
                         sibling_binding_column, binding_column,
                         hide_binding_column, append_condition=None,
                         title=None, **kwargs):
        """Zpracuj klíèové argumenty konstruktoru a inicializuj atributy.
        
        Argumenty:

          title -- ???
          sibling_name -- jméno specifikace hlavního formuláøe; øetìzec
          sibling_row -- funkce bez argumentù, která vrátí aktuální datový
            øádek hlavního formuláøe.
          sibling_binding_column -- identifikátor vazebního sloupce v hlavním
            formuláøi; øetìzec
          binding_column -- identifikátor vazebního sloupce ve vedlej¹ím
            formuláøi; øetìzec
          hide_binding_column -- pravdivá hodnota zpùsobí, ¾e vazební sloupec
            nebude zobrazen.
          append_condition -- None nebo funkce jednoho argumentu, kterým je
            aktuální øádek hlavního formuláøe. V tomto pøípadì musí funkce
            vrátit instanci Operator, která se pøipojí k implicitní
            podmínce provazující vazební sloupce.

        """
        column_condition = lambda row: pytis.data.EQ(binding_column,
                                                   row[sibling_binding_column])
        if append_condition:
            condition = lambda row: pytis.data.AND(column_condition(row),
                                                   append_condition(row))
        else:
            condition = column_condition
        self._sibling_name = sibling_name
        self._sibling_row = sibling_row
        self._title = title
        self._hide_binding_column = hide_binding_column
        self._binding_column = binding_column
        super_(SideBrowseForm)._init_attributes(self, condition, **kwargs)

    def _default_columns(self):
        columns = super(SideBrowseForm, self)._default_columns()
        if self._hide_binding_column:
            return tuple([c for c in columns if c != self._binding_column])
        else:
            return columns
        
    def _init_filter(self):
        self.filter({})

    def title(self):
        if self._title is not None:
            return self._title
        return super_(SideBrowseForm).title(self)
        
    def _formatter_parameters(self):
        parameters = FilteredBrowseForm._formatter_parameters(self)
        extra_parameters = {self._sibling_name+'/'+pytis.output.P_ROW:
                            self._sibling_row()}
        parameters.update(extra_parameters)
        return parameters

    def _update_selection_colors(self):
        g = self._grid
        if focused_window() is not self:
            g.ClearSelection()
        else:
            g.SelectRow(g.GetGridCursorRow())
            super_(SideBrowseForm)._update_selection_colors(self)
