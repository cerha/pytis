# -*- coding: iso-8859-2 -*-

# Prezentace dat v políèkách.
# 
# Copyright (C) 2002, 2003, 2004, 2005 Brailcom, o.p.s.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""Prezentace dat v políèkách.

_Políèkem_ se zde rozumí abstraktní element u¾ivatelského rozhraní pøijímající
textová data, nikoliv konkrétní forma zobrazení dat.

"""

import copy

import pytis.data

from pytis.presentation import *
from pytis.util import *


class PresentedRow(object):
    """Øádek prezentovaných dat.

    Tøída je mezièlánkem mezi datovým øádkem a jeho finální prezentací.  Na
    rozdíl od datového øádku obsahuje v¹echna políèka dané specifikacemi
    políèek 'FieldSpec'.  Na druhou stranu ale ji¾ neøe¹í konkrétní prezentaci
    dat pøesahující jejich zformátování do stringu.

    """
    class _Column:
        def __init__(self, id_, type_, computer, line_separator,
                     default, editable, check, codebook_runtime_filter):
            self.id = id_
            self.type = type_
            self.computer = computer
            self.line_separator = line_separator
            self.default = default
            self.editable = editable
            self.check = check
            self.codebook_runtime_filter = codebook_runtime_filter
            
    def __init__(self, fieldspec, data, row, prefill=None, singleline=False,
                 change_callback=None, editability_change_callback=None,
                 new=False):
        """Inicializuj prezentaci øádku.
        
        Argumenty:

          fieldspec -- sekvence specifikací políèek, instancí tøídy
            'FieldSpec'
          data -- odpovídající datový objekt, instance tøídy 'pytis.data.Data'
          row -- data øádku, viz ní¾e
          prefill -- slovník hodnot pro inicializaci øádku namísto výchozích
            hodnot. Slovník je klíèovaný pøes textový identifikátor sloupce.
            Hodnotami jsou instance tøídy Value, v pøípadì nového záznamu
            (argument 'row' je 'None') mohou být pou¾ity i u¾ivatelské hodnoty.
            Takto lze pøedvyplòit pouze políèka, k nim¾ existuje odpovídající
            sloupec v datovém objektu -- plnì virtuální políèka mají hodnotu
            v¾dy urèenou pomocí computeru (viz. argument 'computer'
            konstruktoru tøídy 'FieldSpec').
          singleline -- právì kdy¾ je pravdivé, stringové hodnoty v¹ech políèek
            budou zformátovány jako jednoøádkové
          change_callback -- funkce jednoho argumentu (id políèka) volaná pøi
            nepøímé zmìnì políèka (tj. pøi pøepoèítávání hodnot), která
            oznamuje \"neèekané\" zmìny políèek v prezentovaném row; je-li
            'None', není ¾ádná taková funkce volána
          editability_change_callback -- funkce dvou argumentù (id políèka,
            pøíznak editovatelnosti) volaná pøi nepøímé zmìnì editovatelnosti
            políèka.  Voláním této funkce øádek oznamuje, ¾e v dùsledku zmìny v
            jiných políèkách se dané políèko stalo editovatelným (druhý
            argument je pravdivý), èi naopak (druhý argument je nepravdivý);
            je-li 'None', není zmìna editovatelnosti oznamována.
          new -- flag urèující, zda se jedná o novì vytváøený záznam (nikoliv
            editaci záznamu ji¾ existujícího)

        Prezentaèní podoba je vytvoøena z dat specifikovaných argumentem 'row',
        který mù¾e mít nìkterou z následujících hodnot:

          None -- bude vytvoøen zbrusu nový øádek odpovídající 'fieldspec'
          instance 'PresentedRow' -- bude vytvoøena kopie zadaného øádku, oba
            musí mít shodnou specifikaci políèek
          instance 'pytis.data.Row' -- bude vytvoøena prezentace z daného
            datového øádku

        Ve v¹ech pøípadech je rozhodující podoba 'row' v okam¾iku volání tohoto
        konstruktoru, pozdìj¹í pøípadné destruktivní zmìny 'row' nemají na novì
        vytvoøenou instanci tøídy 'PresentedRow' vliv.

        """
        assert is_sequence(fieldspec)
        # TODO: pytis.remote vy¾aduje inicializaci Pyro, co¾ není v¾dy to pravé
        # oøechové.  `data' by stejnì mìlo být jednotného typu, je tøeba to
        # nìjak promyslet.
        #assert isinstance(data, pytis.data.Data) or \
        #       isinstance(data, pytis.remote.RemoteData)
        assert row is None or isinstance(row, (PresentedRow, pytis.data.Row))
        assert change_callback is None or callable(change_callback)
        assert editability_change_callback is None or \
               callable(editability_change_callback)
        assert prefill is None or isinstance(prefill, types.DictType)
        assert isinstance(singleline, types.BooleanType)
        assert isinstance(new, types.BooleanType)
        self._fieldspec = fieldspec
        self._data = data
        self._singleline = singleline
        self._change_callback = change_callback
        self._editability_change_callback = editability_change_callback
        self._process_fieldspec()
        self._virtual = {}
        self._new = new
        self._cache = {}
        self._set_row(row, prefill=prefill)

    def _set_row(self, row, reset=True, prefill=None):
        self._row = self._init_row(row, prefill=prefill)
        if reset:
            self._original_row = copy.copy(self._row)
        self._resolve_dependencies()
        
    def _process_fieldspec(self):
        data = self._data
        # Pro ka¾dé políèko si zapamatuji seznam poèítaných políèek, která na
        # nìm závisí (obrácené mapování ne¾ ve specifikacích).
        self._dependent = {}
        self._editability_dependent = {}
        self._codebook_runtime_filter_dependent = {}
        # Pro v¹echna poèítaná políèka si pamatuji, zda potøebují pøepoèítat,
        # èi nikoliv (po pøepoèítání je políèko èisté, po zmìnì políèka na
        # kterém závisí jiná políèka nastavím závislým políèkùm pøíznak dirty).
        # Pøepoèítávání potom mohu provádìt a¾ pøi skuteèném po¾adavku na
        # získání hodnoty políèka.
        self._dirty = {}
        self._editability_dirty = {}
        self._editable = {}
        self._columns = {}
        for f in self._fieldspec:
            key = f.id()
            c = self._Column(key, f.type(data), f.computer(),
                             f.line_separator(), f.default(), f.editable(),
                             f.check(), f.codebook_runtime_filter())
            self._columns[key] = c
            if c.computer is not None:
                self._dirty[key] = True
                for dep in c.computer.depends():
                    if self._dependent.has_key(dep):
                        self._dependent[dep].append(key)
                    else:
                        self._dependent[dep] = [key]
            if isinstance(c.editable, Computer):
                self._editable[key] = True
                self._editability_dirty[key] = True
                for dep in c.editable.depends():
                    if self._editability_dependent.has_key(dep):
                        self._editability_dependent[dep].append(key)
                    else:
                        self._editability_dependent[dep] = [key]
            if c.codebook_runtime_filter is not None:
                for dep in c.codebook_runtime_filter.depends():
                    if self._codebook_runtime_filter_dependent.has_key(dep):
                        self._codebook_runtime_filter_dependent[dep].append(key)
                    else:
                        self._codebook_runtime_filter_dependent[dep] = [key]
                provider = c.codebook_runtime_filter.function()
                e = c.type.enumerator()
                e.set_runtime_filter_provider(provider, (self,))
                        
    def _init_row(self, row, prefill=None):
        self._cache = {}
        if row is None:
            def genval(c):
                key = c.id()
                if prefill is not None and prefill.has_key(key):
                    value = prefill[key]
                    # Pro Codebooky radìji taky vytvoøíme novou instanci
                    if not isinstance(value, pytis.data.Value):
                        value = pytis.data.Value(c.type(), value)
                    else:
                        value = pytis.data.Value(c.type(), value.value())
                    if self._dirty.has_key(key):
                        self._dirty[key] = False
                else:
                    if self._columns.has_key(key):
                        field = self._columns[key]
                        default = field.default
                        t = field.type
                        if default is None:
                            value = t.default_value()
                        else:
                            value = pytis.data.Value(t, default())
                            if self._dirty.has_key(key):
                                self._dirty[key] = False
                    else:
                        value = c.type().default_value()
                return key, value
            for key in self._dirty.keys():
                self._dirty[key] = True
            row_data = map(genval, self._data.columns())
            row = pytis.data.Row(row_data)
        else:
            if isinstance(row, pytis.data.Row):
                row = copy.copy(row)
            elif isinstance(row, PresentedRow):
                row = copy.copy(row._row)
            else:
                raise Exception('Invalid argument row:', row)
            if prefill is not None:
                row.update(prefill)
            for key in self._dirty.keys():
                self._dirty[key] = not row.has_key(key)
        return row

    def __getitem__(self, key):
        """Vra» hodnotu políèka 'key' jako instanci tøídy 'pytis.data.Value'.
        
        'key' je id políèka (øetìzec) identifikující existující políèko, jinak
        je chování metody nedefinováno.
        
        """
        if self._row.has_key(key):
            value = self._row[key]
        else:
            value = self._virtual.get(key)
        if value is None or self._dirty.has_key(key) and self._dirty[key]:
            column = self._columns[key]
            func = column.computer.function()
            new_value = pytis.data.Value(column.type, func(self))
            self._dirty[key] = False
            if value is None or new_value.value() != value.value():
                value = new_value
                if self._row.has_key(key):
                    self._row[key] = value
                else:
                    self._virtual[key] = value
                if self._change_callback is not None:
                    self._change_callback(key)
        return value

    def __setitem__(self, key, value):
        assert isinstance(value, pytis.data.Value)
        column = self._columns[key]
        assert value.type() == column.type, \
               "Invalid type for '%s': %s (expected %s)" % \
               (key, value.type(), column.type)
        self._cache = {}
        # Pokus o nastavení virtuálních políèek ti¹e ignorujeme...
        if self._row.has_key(key) and self._row[key] != value:
            self._row[key] = value
            self._resolve_dependencies(key)
                
    def __str__(self):
        if hasattr(self, '_row'):
            items = []
            for spec in self._fieldspec:
                items.append(spec.id() + '=' + str(self[spec.id()]))
            return '<PresentedRow: %s>' % string.join(items, ', ')
        else:
            return super(PresentedRow, self).__str__()

    def _mark_dependent_dirty(self, key):
        # Rekurzivnì oznaè závislá políèka.
        # Vra» pravdu, pokud k oznaèení nìjakých políèek do¹lo.
        if self._dependent.has_key(key):
            for k in self._dependent[key]:
                self._dirty[k] = True
                self._mark_dependent_dirty(k)
            return True
        else:
            return False
    
    def _resolve_dependencies(self, key=None):
        # Recompute dependencies for all fields when key is None or recompute
        # just fields depending on a field specified by key (after its change).
        # TODO: Musí se to dìlat v¾dy?  Napø. i pøi set_row z BrowseFormu?
        invoke_callbacks = False
        if key:
            invoke_callbacks = self._mark_dependent_dirty(key)
        self._notify_runtime_filter_change(key)
        self._recompute_editability(key)
        if invoke_callbacks and self._change_callback is not None:
            # Zavolej 'chage_callback' pro v¹echna zbylá "dirty" políèka.
            # Políèka, která byla oznaèena jako "dirty" ji¾ buïto byla
            # pøepoèítána a callback byl zavolán bìhem pøepoèítávání
            # editovatelnosti a runtime codebookù, nebo zùstala "dirty" a musíme
            # tedy jejich callback zavolat teï.
            dirty = [k for k in self._dirty.keys() if self._dirty[k]]
            for k in dirty:
                self._change_callback(k)
    
    def _recompute_editability(self, key=None):
        if key is None:
            keys = self._editable.keys()
        elif self._editability_dependent.has_key(key):
            keys = self._editability_dependent[key]
        else:
            return
        if self._editability_change_callback:
            for k in keys:
                old = self._editable[k]
                new = self._compute_editability(k)
                if old != new:
                    self._editability_change_callback(k, new)
        else:
            for k in keys:
                self._editability_dirty[k] = True

    def _compute_editability(self, key):
        # Vypoèti editovatelnost políèka a vra» výsledek (jako boolean).
        func = self._columns[key].editable.function()
        self._editable[key] = result = func(self, key)
        self._editability_dirty[key] = False
        return result
    
    def _notify_runtime_filter_change(self, key=None):
        if key is None:
            columns = [c for c in self._columns.values()
                       if c.codebook_runtime_filter is not None]
        elif self._codebook_runtime_filter_dependent.has_key(key):
            columns = [self._columns[k]
                       for k in self._codebook_runtime_filter_dependent[key]]
        else:
            return
        for c in columns:
            c.type.enumerator().notify_runtime_filter_change()
 
    def row(self):
        """Vra» aktuální datový øádek, jako instanci 'pytis.data.Row'.

        Typy sloupcù takto vráceného øádku jsou shodné s typy z datového
        objektu, pro sloupce v datovém objektu pøítomné.

        """
        data = self._data
        row_data = []
        for key, value in self._row.items():
            c = data.find_column(key)
            if c is not None:
                if self._dirty.has_key(key) and self._dirty[key]:
                    value = self[key]
                value = pytis.data.Value(c.type(), value.value())
            row_data.append((key, value))
        return pytis.data.Row(row_data)

    def data(self):
        """Vra» odpovídající datový objekt øádku."""
        return self._data

    def format(self, key, **kwargs):
        """Vra» stringovou hodnotu políèka 'key'.

        Argumenty:

          'key' -- id políèka (øetìzec) identifikující existující políèko,
            jinak je chování metody nedefinováno.
          'kwargs' -- klíèové argumenty které budou pou¾ity pøi volání metody
            'export()' pro získání øetìzcové reprezentace hodnoty.
        
        """
        try:
            return self._cache[key]
        except KeyError:
            pass
        try:
            value = self[key]
        except KeyError:
            # Mù¾e nastat napøíklad v pøípadì, kdy k danému sloupci nejsou
            # pøístupová práva.
            svalue = ''
        else:
            svalue = value.export(**kwargs)
        column = self._columns[key]
        if self._singleline and column.line_separator is not None:
            svalue = string.join(svalue.splitlines(), column.line_separator)
        self._cache[key] = svalue
        return svalue

    def set_row(self, row, reset=False):
        """Nastav aktuální data na 'row'.

        'row' má stejný význam jako stejnojmenný argument metody '__init__()'.

        Pravdivá hodnota argumentu 'reset' zpùsobí to, ¾e tato nová hodnota
        øádku bude nadále pova¾ována za pùvodní, co¾ má vliv na funkci metod
        'changed()' a 'original_row()'.

        Tuto metodu je vhodné vyu¾ívat pro koncepci aktuálního øádku v tabulce
        s nemìnnými sloupci a datovým objektem.  U¹etøí se tak chroustání
        specifikací uvnitø této tøídy.
        
        """
        self._set_row(row, reset=reset)

    def fields(self):
        """Vra» seznam v¹ech políèek."""
        return self._fieldspec
        
    def has_key(self, key):
        """Vra» pravdu, pokud je políèko daného klíèe v øádku obsa¾eno."""
        return self._columns.has_key(key)
        
    def keys(self):
        """Vra» seznam identifikátorù v¹ech políèek obsa¾ených v tomto øádku."""
        return self._columns.keys()
        
    def original_row(self):
        """Vra» øádek obsahující pùvodní hodnoty øádku pøed pøípadnými zmìnami.

        Vrácená hodnota je instance 'pytis.data.Row' nebo 'None', ne nutnì
        toto¾ná (ve smyslu 'id()') s øádkem zadaným v konstruktoru.

        Pozor, pokud byl øádek pøedaný konstruktoru `None', metoda sice vrátí
        inicializovaný prázdný øádek, ale hodnoty poèítaných políèek v nìm
        nebudou vypoèteny.
        
        """
        return self._original_row

    def changed(self):
        """Vra» pravdu, právì kdy¾ byl øádek zmìnìn.

        Øádek se pova¾uje za zmìnìný, není-li shodný s øádkem vytvoøeným z dat
        zadaných v konstruktoru, ve smyslu operátoru `='.

        """
        return self._row != self._original_row

    def field_changed(self, key):
        """Vra» pravdu, právì kdy¾ bylo políèko dané 'key' zmìnìno.

        """
        return self._row.has_key(key) and \
               self._row[key] != self._original_row[key]

    def new(self):
        """Vra» pravdu, právì kdy¾ se jedná o nový záznam."""
        return self._new
    
    def editable(self, key):
        """Vra» pravdu, právì kdy¾ je políèko dané 'key' editovatelné.

        Význam argumentu 'key' je stejný jako v metodì '__getitem__'.

        """
        if self._editable.has_key(key):
            if self._editability_dirty[key]:
                return self._compute_editability(key)
            else:
                return self._editable[key]
        else:
            editable = self._columns[key].editable
            return editable == Editable.ALWAYS or \
                   (editable == Editable.ONCE and self._new)

    # Nakonec to není nikde potøeba, ale kdyby, staèí odkomentovat a dopsat
    # test...
    #def accessible(self, key, permission):
    #    """Vra» pravdu, právì kdy¾ má u¾ivatel právo pøístupu k danému políèku.
    #
    #    Argumenty:
    #    
    #      'key' -- stejnì jako v metodì '__getitem__'.
    #      'permission' -- jedna z konstant tøídy 'pytis.data.Permission'
    #        urèující, které pøístupové právo se má testovat.
    #
    #    Pokud dané políèko není souèástí datového øádku (jde o virtuální
    #    políèko), vrací v¾dy None.
    #        
    #    """
    #    if self._row.has_key(key):
    #        return self._data.accessible(key, permission)
    #    else:
    #        return None

    def check(self):
        """Proveï kontrolu vzájemné integrity dat øádku.
        
        Metoda provede v¹echny existující 'check' funkce definované ve
        'FieldSpec' obsa¾ených políèek.  Pøi neúspìchu kontroly nìkterého
        políèka není provádìna ¾ádná akce, pouze je vráceno id tohoto políèka a
        provedeno zalogování.  Oèekává se, ¾e pøípadná interakce s u¾ivatelem
        je provádìna v rámci check funkce.

        Vrací: Id políèka, pokud nìkterá kontrolní funkce neprojde, nebo None v
        pøípadì, ¾e je v¹e v poøádku.

        """
        # TODO: Tato metoda bude zru¹ena, hned jak se pøestanou pou¾ívat funkce
        # 'check' ve 'FieldSpec', které¾to mají být nahrazeny stejnojmennou
        # funkcí ve 'ViewSpec', ke které zde v¹ak není pøístup, tak¾e se volá
        # na úrovni formuláøe.
        for spec in self._fieldspec:
            c = self._columns[spec.id()]
            if c.check is not None and not c.check(self):
                log(EVENT, 'Kontrola integrity selhala:', (c.id, self))
                return c.id
        return None

        
    def refvalue(self, key):
        """Metoda existuje jen kvùli zpìtné kompatibilitì, ale vrací v¾dy None.

        Brzy bude zru¹ena, tak¾e je tøeba v¹echna její pou¾ití odstranit.
        
        """
        log(EVENT, "Pou¾ita potlaèená metoda 'PresentedRow.refvalue()'!")
        # TODO: Zru¹it!!!
        return None
