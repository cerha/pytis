#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (C) 2011, 2012, 2014 Brailcom, o.p.s.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# ATTENTION: This should be updated on each code change.
_VERSION = '2014-12-18 15:20'

import argparse
import copy
import imp
import multiprocessing
import os
import platform
import re
import shutil
import sys
import tarfile
import tempfile
import time

import paramiko
import rpyc
import x2go
import PyZenity as zenity

import pytis.remote

def on_windows():
    return platform.system() == 'Windows'

def run_directory():
    return sys.path[0]

_NONE = object()

class ClientException(Exception):
    pass

class Configuration(object):

    _CONFIGURATION_FILE = 'config.py'
    _RPYC_FILE = 'rpyc'

    def __init__(self):
        self._directory = self._configuration_directory()
        self._configuration = self._read_configuration()

    def _configuration_directory(self):
        basename = '_pytis_x2go' if on_windows() else '.pytis-x2go'
        dirname = os.path.expanduser(os.path.join('~', basename))
        if not os.access(dirname, os.F_OK):
            try:
                os.mkdir(dirname, 0700)
            except Exception as e:
                raise ClientException("Can't create client directory: %s" % (dirname,), e)
        elif not os.access(dirname, os.R_OK | os.W_OK | os.X_OK):
            raise ClientException("Client directory not accessible: %s" % (dirname,))
        return dirname

    def _configuration_file(self, filename):
        return os.path.join(self._configuration_directory(), filename)

    def _read_configuration(self):
        filename = self._configuration_file(self._CONFIGURATION_FILE)
        if not os.access(filename, os.F_OK):
            try:
                open(filename, 'w').close()
            except Exception as e:
                raise ClientException("Can't create client configuration file: %s" % (filename,), e)
        elif not os.access(filename, os.R_OK | os.W_OK):
            raise ClientException("Client configuration not accessible: %s" % (filename,))
        try:
            configuration = imp.load_source('_config', filename)
        except Exception as e:
            raise ClientException("Error when loading client configuration: %s" % (filename,), e)
        return configuration
    
    def get(self, key, type_, default=_NONE):
        args = () if default is _NONE else (default,)
        try:
            value = getattr(self._configuration, key, *args)
        except AttributeError:
            raise ClientException("Configuration parameter not available: %s" % (key,))
        if not isinstance(value, type_) and value != default:
            raise ClientException("Invalid configuration parameter type: %s = %r (is not %s)" %
                                  (key, value, type_,))
        return value

    def set(self, key, value):
        setattr(self._configuration, key, value)

    def rpyc_file(self):
        return self._configuration_file(self._RPYC_FILE)

class RpycInfo(object):

    def __init__(self, configuration, port=None, password=None):
        self._filename = configuration.rpyc_file()
        self._port = port
        self._password = password

    def read(self):
        try:
            f = open(self._filename)
            port = int(f.next().rstrip())
            password = f.next().rstrip()
        except Exception as e:
            raise ClientException("Can't read RPyC info file: %s" % (self._filename,), e)
        self._port = int(port)
        self._password = password

    def store(self):
        try:
            f = open(self._filename, 'w')
            f.write('%s\n%s' % (self._port, self._password,))
            f.close()
        except Exception as e:
            raise ClientException("Error when writing RPyC info file: %s" % (self._filename,), e)
        
    def port(self):
        return self._port

    def password(self):
        return self._password

class PytisClient(x2go.X2GoClient):

    _DEFAULT_RPYC_PORT = 10000
    _MAX_RPYC_PORT_ATTEMPTS = 100
    _DEFAULT_KEY_FILENAME = os.path.expanduser('~/.ssh/id_rsa')

    def __init__(self, *args, **kwargs):
        super(PytisClient, self).__init__(*args, **kwargs)
        self._pytis_port_queue = multiprocessing.Queue()
        self._pytis_password_queue = multiprocessing.Queue()
        self._pytis_terminate = multiprocessing.Value('b', False)
    
    def pytis_setup(self, s_uuid, configuration):
        # Configuration transfer to the server
        session = self.get_session(s_uuid)
        control_session = session.control_session
        # It would be better to use self.info_backend or
        # self.get_session_info(s_uuid) as the source of remote_container
        # (instead of _x2go_remote_home + '/.x2go') and agent_pid (instead of
        # application) but this information is often unavailable here for
        # unclear reasons.
        session_id = self.session_registry(s_uuid).terminal_session.session_info.name
        server_file_name = '%s/.x2go/ssh/pytis.%s' % (control_session._x2go_remote_home,
                                                      session_id,)
        class ServerInfo(object):
            def __init__(self):
                self._port = None
                self._password = None
            def set_port(self, port):
                self._port = port
            def set_password(self, password):
                self._password = password
            def write(self):
                if self._port is None or self._password is None:
                    return
                data = '0:%s:%s:' % (self._port, self._password,)
                control_session._x2go_sftp_write(server_file_name, data)
        self._pytis_server_info = ServerInfo()

    def pytis_handle_queues(self):
        def get(queue):
            value = None
            while not queue.empty():
                value = queue.get()
            return value
        password = get(self._pytis_password_queue)
        port = get(self._pytis_port_queue)
        if password is not None or port is not None:
            info = self._pytis_server_info
            if password is not None:
                info.set_password(password)
            if port is not None:
                info.set_port(port)
            info.write()

    def pytis_start_processes(self, configuration):
        # RPyC server
        import pytis.remote.pytisproc as pytisproc
        rpyc_stop_queue = multiprocessing.Queue()
        rpyc_port = multiprocessing.Value('i', 0)
        ssh_tunnel_alive = multiprocessing.Value('b', False)
        def check_rpyc_server():
            process = None
            while True:
                if self._pytis_terminate.value:
                    if process is not None:
                        process.terminate()
                    sys.exit()
                # Look for a running RPyC instance
                running = True
                rpyc_info = RpycInfo(configuration)
                try:
                    rpyc_info.read()
                except ClientException:
                    running = False
                if running:
                    # Check whether it's our instance
                    # We must be careful here not to send the password to an RPyC instance
                    # of another user.
                    port = rpyc_info.port()
                    password = rpyc_info.password()
                    authenticator = pytisproc.PasswordAuthenticator(password,
                                                                    ssh_tunnel=ssh_tunnel_alive)
                    try:
                        authenticator.connect('localhost', port)
                    except:
                        running = False
                if not rpyc_stop_queue.empty():
                    while not rpyc_stop_queue.empty():
                        rpyc_stop_queue.get()
                    if running and process is not None:
                        process.terminate()
                    running = False
                # If no running RPyC instance was found then start one
                if not running:
                    authenticator = pytisproc.PasswordAuthenticator()
                    default_port = self._DEFAULT_RPYC_PORT
                    port_limit = default_port + self._MAX_RPYC_PORT_ATTEMPTS
                    for port in range(default_port, port_limit):
                        try:
                            server = rpyc.utils.server.ForkingServer(pytisproc.PytisUserService,
                                                                     hostname='localhost',
                                                                     port=port,
                                                                     authenticator=authenticator)
                            break
                        except:
                            pass
                    else:
                        raise ClientException("No free port found for RPyC in the range %s-%s" %
                                              (default_port, port_limit - 1,))
                    server.service.authenticator = authenticator
                    rpyc_port.value = port
                    rpyc_info = RpycInfo(configuration, port=port,
                                         password=authenticator.password())
                    rpyc_info.store()
                    process = multiprocessing.Process(target=server.start)
                    process.start()
                    self._pytis_password_queue.put(rpyc_info.password())
                time.sleep(1)
        multiprocessing.Process(target=check_rpyc_server).start()
        # ssh tunnel
        def check_ssh_tunnel():
            try:
                password = configuration.get('password', basestring)
            except ClientException:
                password = None
            try:
                key_filename = configuration.get('key_filename', basestring)
            except ClientException:
                key_filename = None
            while True:
                while rpyc_port.value == 0:
                    time.sleep(0.1)
                port = multiprocessing.Value('i', 0)
                tunnel = pytis.remote.ReverseTunnel(configuration.get('host', basestring),
                                                    rpyc_port.value, ssh_forward_port=port,
                                                    ssh_user=configuration.get('user', basestring),
                                                    ssh_password=password,
                                                    key_filename=key_filename)
                ssh_tunnel_alive.value = True
                tunnel.start()
                while not port.value and tunnel.is_alive():
                    time.sleep(0.1)
                self._pytis_port_queue.put(port.value)
                while True:
                    if self._pytis_terminate.value:
                        tunnel.terminate()
                        sys.exit()
                    if tunnel.is_alive():
                        time.sleep(1)
                    else:
                        ssh_tunnel_alive.value = False
                        # We must restart RPyC as well in order to prevent password leak
                        rpyc_stop_queue.put(True)
                        break
        multiprocessing.Process(target=check_ssh_tunnel).start()

    def terminate_session(self, *args, **kwargs):
        try:
            return super(PytisClient, self).terminate_session(*args, **kwargs)
        finally:
            self._pytis_terminate.value = True

    @classmethod
    def _pytis_ssh_connect(class_, parameters):
        if not parameters['password']:
            parameters['password'] = 'X'
        methods = []
        client = paramiko.SSHClient()
        client.load_system_host_keys()
        if parameters.get('_add_to_known_hosts'):
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        selected_method = None
        while True:
            connect_parameters = dict([(k, v,) for k, v in parameters.items() if k[0] != '_'])
            try:
                client.connect(**connect_parameters)
                break
            except paramiko.ssh_exception.AuthenticationException as e:
                if selected_method == 'publickey':
                    password = zenity.GetText(text="Key Password", password=True,
                                              title="")
                    if password is not None:
                        parameters['password'] = password
                        continue
                if not methods:
                    try:
                        methods = client.get_transport().auth_none(parameters['username'])
                    except paramiko.ssh_exception.BadAuthenticationType as e:
                        methods = e.args[1]
                if 'password' in methods:
                    if 'publickey' in methods:
                        answer = zenity.Question("Default authentication failed",
                                                 title='',
                                                 ok_label="Login using password",
                                                 cancel_label="Login using a key file")
                        selected_method = 'publickey' if not answer else 'password'
                    else:
                        selected_method = 'password'
                elif 'publickey' in methods:
                    selected_method = 'publickey'
                else:
                    raise Exception("No supported ssh connection method available")
                parameters['_method'] = selected_method
                if selected_method == 'password':
                    password = zenity.GetText(text="Login Password", password=True,
                                              title="Password input")
                    if not password:
                        return None
                    parameters['password'] = password
                elif selected_method == 'publickey':
                    ssh_directory = os.path.join(os.path.expanduser('~'), '.ssh', '')
                    key_filename = zenity.GetFilename(title="Select ssh key file",
                                                      filename=ssh_directory)
                    if key_filename is None:
                        return None
                    parameters['key_filename'] = key_filename
                else:
                    raise Exception("Program error")
        return client

    @classmethod
    def _pytis_parse_url(class_, url, add_to_known_hosts=False):
        match = re.match(('^(?P<protocol>(ssh|http(|s)))://'
                          '(|(?P<user>[a-zA-Z0-9_\.-]+)'
                          '(|:(?P<password>.*))@)'
                          '(?P<host>[a-zA-Z0-9\.-]+)'
                          '(|:(?P<port>[0-9]+))'
                          '($|/(?P<path>.*)$)'), url)
        if match is None:
            raise Exception("Invalid broker address", url)
        parameters = match.groupdict()
        protocol = parameters['protocol']
        if protocol != 'ssh':
            raise Exception("Unsupported broker protocol", protocol)
        password = parameters.get('password')
        port = int(parameters.get('port') or '22')
        ssh_parameters = dict(hostname=parameters['host'], port=port,
                              username=parameters['user'], password=password,
                              _add_to_known_hosts=add_to_known_hosts,
                              key_filename=class_._DEFAULT_KEY_FILENAME)
        path = parameters.get('path')
        return ssh_parameters, path

    @classmethod
    def _pytis_select_broker_session(class_, broker_url, add_to_known_hosts):
        parameters, path = class_._pytis_parse_url(broker_url, add_to_known_hosts)
        # Fetch session list
        sessions = ''
        text = ''
        configuration = None
        in_config = False
        client = class_._pytis_ssh_connect(parameters)
        if client is None:
            return
        broker_path = os.path.join('/', path or '/usr/bin/x2gobroker')
        command = "%s --task listsessions" % (broker_path,)
        __stdin, stdout, __stderr = client.exec_command(command)
        while True:
            line = stdout.readline()
            if not line:
                break
            text += line
            if line.strip() == 'START_USER_SESSIONS':
                in_config = True
                continue
            elif line.strip() == 'END_USER_SESSIONS':
                in_config = False
            if in_config:
                sessions += line
        import ConfigParser
        import StringIO
        parser = ConfigParser.ConfigParser()
        parser.readfp(StringIO.StringIO(sessions))
        # Get sessions
        sections = parser.sections()
        data = []
        for s in sections:
            name = parser.get(s, 'name')
            if name == 'pytis-client-upgrade':
                continue
            elif name:
                data.append([s, name])
            else:
                data.append([s, ''])
        # Check for upgrade
        version = parser.get('pytis-client-upgrade', 'version')
        if version and version > _VERSION:
            upgrade_url = parser.get('pytis-client-upgrade', 'url')
            if upgrade_url:
                if zenity.Question("New pytis client version available. Install?",
                                   title='', ok_label="Yes", cancel_label="No"):
                    class_._pytis_upgrade(copy.copy(parameters), upgrade_url)
        # Select session
        answer = zenity.List(['Session id', 'Session name'], title="Select session",
                             data=data)
        session_name = answer and answer[0]
        if not session_name:
            raise Exception("No session selected.")
        configuration = Configuration()
        for o in parser.options(session_name):
            configuration.set(o, parser.get(session_name, o))
        # Fetch additional session parameters
        server_regexp = re.compile('^SERVER:(.*):(.*)$')
        text = ''
        command = "%s --task selectsession --sid %s" % (broker_path, session_name)
        __stdin, stdout, __stderr = client.exec_command(command)
        while True:
            line = stdout.readline()
            if not line:
                break
            text += line
            line = line.strip()
            m = server_regexp.match(line)
            if m is not None:
                host, port = m.groups()
                try:
                    port = int(port)
                except ValueError:
                    raise Exception("Invalid session format", text)
                configuration.set('host', host)
                configuration.set('sshport', port)
        # Finish configuration and return it
        configuration.set('password', parameters['password'])
        configuration.set('key_filename', parameters['key_filename'])
        return configuration

    @classmethod
    def _pytis_upgrade(class_, parameters, upgrade_url):
        upgrade_parameters, path = class_._pytis_parse_url(upgrade_url,
                                                           parameters.get('add_to_known_hosts'))
        parameters.update(upgrade_parameters)
        client = class_._pytis_ssh_connect(parameters)
        if client is None:
            zenity.Error("Couldn't connect to upgrade server")
            return
        install_directory = os.path.normpath(os.path.join(run_directory(), '..', ''))
        old_install_directory = install_directory + '.old'
        tmp_directory = tempfile.mkdtemp(prefix='pytisupgrade')
        pytis_directory = os.path.join(tmp_directory, 'pytis')
        sftp = client.open_sftp()
        f = sftp.open(path)
        tarfile.open(fileobj=f).extractall(path=tmp_directory)
        if not os.path.isdir(pytis_directory):
            zenity.Error("Package unpacking failed")
            return
        os.rename(install_directory, old_install_directory)
        os.rename(pytis_directory, install_directory)
        os.rmdir(tmp_directory)
        shutil.rmtree(old_install_directory)
        zenity.InfoMessage("Pytis successfully upgraded. Restart the application.")
        sys.exit(0)
        
    @classmethod
    def run(class_, broker_url=None, server=None, username=None, command=None,
            key_filename=None, add_to_known_hosts=False):
        # Get parameters
        if on_windows():
            zenity.zen_exec = os.path.join(run_directory(), 'zenity.exe')
        else:
            zenity.zen_exec = 'zenity'
        if broker_url:
            configuration = class_._pytis_select_broker_session(broker_url, add_to_known_hosts)
            if configuration is None:
                return
        else:
            configuration = Configuration()
        if server is None:
            server = configuration.get('host', basestring)
        else:
            configuration.set('host', server)
        port = configuration.get('sshport', int, 22)
        if username is None:
            username = configuration.get('user', basestring)
        else:
            configuration.set('user', username)
        if command is None:
            command = configuration.get('command', basestring)
        else:
            command = configuration.set('command', command)
        try:
            password = configuration.get('password', basestring)
        except ClientException:
            password = None
        if key_filename is None:
            try:
                key_filename = configuration.get('key_filename', basestring)
            except ClientException:
                key_filename = class_._DEFAULT_KEY_FILENAME
        else:
            configuration.set('key_filename', key_filename)
        parameters = dict(hostname=server, port=port, username=username, password=password,
                          key_filename=key_filename, _add_to_known_hosts=add_to_known_hosts)
        # Check connection parameters and update password
        client = class_._pytis_ssh_connect(parameters)
        if client is None:
            return
        client = None
        password = parameters['password']
        configuration.set('password', password)
        # Run
        client = class_(use_cache=False, loglevel=x2go.log.loglevel_DEBUG)
        s_uuid = client.register_session(server, port=port, username=username,
                                         key_filename=key_filename,
                                         cmd=command, add_to_known_hosts=add_to_known_hosts)
        client.pytis_start_processes(configuration)
        session = client.session_registry(s_uuid)
        session.sshproxy_params['key_filename'] = key_filename
        session.sshproxy_params['look_for_keys'] = False
        client.connect_session(s_uuid, username=username, password=password)
        client.clean_sessions(s_uuid)
        client.start_session(s_uuid)
        client.pytis_setup(s_uuid, configuration)
        try:
            while client.session_ok(s_uuid):
                client.pytis_handle_queues()
                time.sleep(0.1)
        except KeyboardInterrupt:
            pass
        client.terminate_session(s_uuid)
           
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--broker-url')
    parser.add_argument('--server')
    parser.add_argument('--username')
    parser.add_argument('--command')
    parser.add_argument('--ssh-privkey')
    parser.add_argument('--add-to-known-hosts', action='store_true')
    args = parser.parse_args()
    PytisClient.run(args.broker_url, args.server, args.username, args.command, args.ssh_privkey,
                    args.add_to_known_hosts)

# Local Variables:
# time-stamp-pattern: "30/^_VERSION = '%Y-%02m-%02d %02H:%02M'"
# End:
