#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (C) 2011, 2012, 2014 Brailcom, o.p.s.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# ATTENTION: This should be updated on each code change.
_VERSION = '2014-12-11 14:34'

import argparse
import imp
import multiprocessing
import os
import platform
import re
import subprocess
import sys
import time

import paramiko
import rpyc
import x2go

import pytis.remote

def on_windows():
    return platform.system() == 'Windows'

_NONE = object()

class ClientException(Exception):
    pass

class Configuration(object):

    _CONFIGURATION_FILE = 'config.py'
    _RPYC_FILE = 'rpyc'

    def __init__(self):
        self._directory = self._configuration_directory()
        self._configuration = self._read_configuration()

    def _configuration_directory(self):
        basename = '_pytis_x2go' if on_windows() else '.pytis-x2go'
        dirname = os.path.expanduser(os.path.join('~', basename))
        if not os.access(dirname, os.F_OK):
            try:
                os.mkdir(dirname, 0700)
            except Exception as e:
                raise ClientException("Can't create client directory: %s" % (dirname,), e)
        elif not os.access(dirname, os.R_OK | os.W_OK | os.X_OK):
            raise ClientException("Client directory not accessible: %s" % (dirname,))
        return dirname

    def _configuration_file(self, filename):
        return os.path.join(self._configuration_directory(), filename)

    def _read_configuration(self):
        filename = self._configuration_file(self._CONFIGURATION_FILE)
        if not os.access(filename, os.F_OK):
            try:
                open(filename, 'w').close()
            except Exception as e:
                raise ClientException("Can't create client configuration file: %s" % (filename,), e)
        elif not os.access(filename, os.R_OK | os.W_OK):
            raise ClientException("Client configuration not accessible: %s" % (filename,))
        try:
            configuration = imp.load_source('_config', filename)
        except Exception as e:
            raise ClientException("Error when loading client configuration: %s" % (filename,), e)
        return configuration
    
    def get(self, key, type_, default=_NONE):
        args = () if default is _NONE else (default,)
        try:
            value = getattr(self._configuration, key, *args)
        except AttributeError:
            raise ClientException("Configuration parameter not available: %s" % (key,))
        if not isinstance(value, type_) and value != default:
            raise ClientException("Invalid configuration parameter type: %s = %r (is not %s)" %
                                  (key, value, type_,))
        return value

    def set(self, key, value):
        setattr(self, key, value)

    def rpyc_file(self):
        return self._configuration_file(self._RPYC_FILE)

class RpycInfo(object):

    def __init__(self, configuration, port=None, password=None):
        self._filename = configuration.rpyc_file()
        self._port = port
        self._password = password

    def read(self):
        try:
            f = open(self._filename)
            port = int(f.next().rstrip())
            password = f.next().rstrip()
        except Exception as e:
            raise ClientException("Can't read RPyC info file: %s" % (self._filename,), e)
        self._port = int(port)
        self._password = password

    def store(self):
        try:
            f = open(self._filename, 'w')
            f.write('%s\n%s' % (self._port, self._password,))
            f.close()
        except Exception as e:
            raise ClientException("Error when writing RPyC info file: %s" % (self._filename,), e)
        
    def port(self):
        return self._port

    def password(self):
        return self._password

class PytisClient(x2go.X2GoClient):

    _DEFAULT_RPYC_PORT = 10000
    _MAX_RPYC_PORT_ATTEMPTS = 100

    def __init__(self, *args, **kwargs):
        super(PytisClient, self).__init__(*args, **kwargs)
        self._pytis_port_queue = multiprocessing.Queue()
        self._pytis_password_queue = multiprocessing.Queue()
        self._pytis_terminate = multiprocessing.Value('b', False)
    
    def pytis_setup(self, s_uuid, configuration):
        # Configuration transfer to the server
        session = self.get_session(s_uuid)
        control_session = session.control_session
        # It would be better to use self.info_backend or
        # self.get_session_info(s_uuid) as the source of remote_container
        # (instead of _x2go_remote_home + '/.x2go') and agent_pid (instead of
        # application) but this information is often unavailable here for
        # unclear reasons.
        session_id = self.session_registry(s_uuid).terminal_session.session_info.name
        server_file_name = '%s/.x2go/ssh/pytis.%s' % (control_session._x2go_remote_home,
                                                      session_id,)
        class ServerInfo(object):
            def __init__(self):
                self._port = None
                self._password = None
            def set_port(self, port):
                self._port = port
            def set_password(self, password):
                self._password = password
            def write(self):
                if self._port is None or self._password is None:
                    return
                data = '0:%s:%s:' % (self._port, self._password,)
                control_session._x2go_sftp_write(server_file_name, data)
        self._pytis_server_info = ServerInfo()

    def pytis_handle_queues(self):
        def get(queue):
            value = None
            while not queue.empty():
                value = queue.get()
            return value
        password = get(self._pytis_password_queue)
        port = get(self._pytis_port_queue)
        if password is not None or port is not None:
            info = self._pytis_server_info
            if password is not None:
                info.set_password(password)
            if port is not None:
                info.set_port(port)
            info.write()

    def pytis_start_processes(self, configuration):
        # RPyC server
        import pytis.remote.pytisproc as pytisproc
        rpyc_stop_queue = multiprocessing.Queue()
        rpyc_port = multiprocessing.Value('i', 0)
        ssh_tunnel_alive = multiprocessing.Value('b', False)
        def check_rpyc_server():
            process = None
            while True:
                if self._pytis_terminate.value:
                    if process is not None:
                        process.terminate()
                    sys.exit()
                # Look for a running RPyC instance
                running = True
                rpyc_info = RpycInfo(configuration)
                try:
                    rpyc_info.read()
                except ClientException:
                    running = False
                if running:
                    # Check whether it's our instance
                    # We must be careful here not to send the password to an RPyC instance
                    # of another user.
                    port = rpyc_info.port()
                    password = rpyc_info.password()
                    authenticator = pytisproc.PasswordAuthenticator(password,
                                                                    ssh_tunnel=ssh_tunnel_alive)
                    try:
                        authenticator.connect('localhost', port)
                    except:
                        running = False
                if not rpyc_stop_queue.empty():
                    while not rpyc_stop_queue.empty():
                        rpyc_stop_queue.get()
                    if running and process is not None:
                        process.terminate()
                    running = False
                # If no running RPyC instance was found then start one
                if not running:
                    authenticator = pytisproc.PasswordAuthenticator()
                    default_port = self._DEFAULT_RPYC_PORT
                    port_limit = default_port + self._MAX_RPYC_PORT_ATTEMPTS
                    for port in range(default_port, port_limit):
                        try:
                            server = rpyc.utils.server.ForkingServer(pytisproc.PytisUserService,
                                                                     hostname='localhost',
                                                                     port=port,
                                                                     authenticator=authenticator)
                            break
                        except:
                            pass
                    else:
                        raise ClientException("No free port found for RPyC in the range %s-%s" %
                                              (default_port, port_limit - 1,))
                    server.service.authenticator = authenticator
                    rpyc_port.value = port
                    rpyc_info = RpycInfo(configuration, port=port,
                                         password=authenticator.password())
                    rpyc_info.store()
                    process = multiprocessing.Process(target=server.start)
                    process.start()
                    self._pytis_password_queue.put(rpyc_info.password())
                time.sleep(1)
        multiprocessing.Process(target=check_rpyc_server).start()
        # ssh tunnel
        def check_ssh_tunnel():
            while True:
                while rpyc_port.value == 0:
                    time.sleep(0.1)
                port = multiprocessing.Value('i', 0)
                tunnel = pytis.remote.ReverseTunnel(configuration.get('host', basestring),
                                                    rpyc_port.value, ssh_forward_port=port,
                                                    ssh_user=configuration.get('user', basestring))
                ssh_tunnel_alive.value = True
                tunnel.start()
                while not port.value and tunnel.is_alive():
                    time.sleep(0.1)
                self._pytis_port_queue.put(port.value)
                while True:
                    if self._pytis_terminate.value:
                        tunnel.terminate()
                        sys.exit()
                    if tunnel.is_alive():
                        time.sleep(1)
                    else:
                        ssh_tunnel_alive.value = False
                        # We must restart RPyC as well in order to prevent password leak
                        rpyc_stop_queue.put(True)
                        break
        multiprocessing.Process(target=check_ssh_tunnel).start()

    def terminate_session(self, *args, **kwargs):
        try:
            return super(PytisClient, self).terminate_session(*args, **kwargs)
        finally:
            self._pytis_terminate.value = True

    @classmethod
    def _pytis_select_broker_session(class_, broker_url):
        match = re.match(('^(?P<protocol>(ssh|http(|s)))://'
                          '(|(?P<user>[a-zA-Z0-9_\.-]+)'
                          '(|:(?P<password>.*))@)'
                          '(?P<host>[a-zA-Z0-9\.-]+)'
                          '(|:(?P<port>[0-9]+))'
                          '($|/(?P<path>.*)$)'), broker_url)
        if match is None:
            raise Exception("Invalid broker address", broker_url)
        broker_parameters = match.groupdict()
        protocol = broker_parameters['protocol']
        if protocol != 'ssh':
            raise Exception("Unsupported broker protocol", protocol)
        password = broker_parameters.get('password')
        port = int(broker_parameters.get('port') or '22')
        # Fetch session list
        section_regexp = re.compile('^[[](.+)[]]$')
        value_regexp = re.compile('^([^ \t=]+) *= *(.*)$')
        sessions = {}
        text = ''
        configuration = None
        in_config = False
        client = paramiko.SSHClient()
        client.load_system_host_keys()
        client.connect(broker_parameters['host'], port=port,
                       username=broker_parameters['user'], password=password)
        command = '/usr/bin/x2gobroker-ssh --task listsessions'
        __stdin, stdout, __stderr = client.exec_command(command)
        while True:
            line = stdout.readline()
            if not line:
                break
            text += line
            line = line.strip()
            if not line:
                continue
            if line == 'START_USER_SESSIONS':
                in_config = True
            elif line == 'END_USER_SESSIONS':
                in_config = False
            elif not in_config:
                continue
            m = section_regexp.match(line)
            if m is not None:
                configuration = sessions[m.group(1)] = Configuration()
                continue
            m = value_regexp.match(line)
            if m is not None:
                if configuration is None:
                    raise Exception("Invalid session list format", text)
                key, value = m.groups()
                if key in ('sshport',):
                    try:
                        value = int(value)
                    except ValueError:
                        raise Exception("Invalid session list format", text)
                configuration.set(key, value)
        # Select session
        if on_windows():
            raise Exception("Session selection not implemented")
        else:
            args = (['zenity', '--list', '--text', "Select session", '--column', "Session"] +
                    sessions.keys())
            try:
                output = subprocess.check_output(args)
            except subprocess.CalledProcessError:
                return None
            session_name = output.rstrip('\r\n')
            configuration = sessions[session_name]
        # Fetch additional session parameters
        server_regexp = re.compile('^SERVER:(.*):(.*)$')
        text = ''
        command = '/usr/bin/x2gobroker-ssh --task selectsession --sid ' + session_name
        __stdin, stdout, __stderr = client.exec_command(command)
        while True:
            line = stdout.readline()
            if not line:
                break
            text += line
            line = line.strip()
            m = server_regexp.match(line)
            if m is not None:
                host, port = m.groups()
                try:
                    port = int(port)
                except ValueError:
                    raise Exception("Invalid session format", text)
                configuration.set('host', host)
                configuration.set('sshport', port)
        return configuration
        
    @classmethod
    def run(class_, broker_url=None):
        if broker_url:
            configuration = class_._pytis_select_broker_session(broker_url)
            if configuration is None:
                return
        else:
            configuration = Configuration()
        server = configuration.get('host', basestring)
        port = configuration.get('sshport', int, 22)
        username = configuration.get('user', basestring)
        command = configuration.get('command', basestring)
        client = class_(use_cache=False, loglevel=x2go.log.loglevel_DEBUG)
        s_uuid = client.register_session(server, port=port, username=username, cmd=command,
                                         add_to_known_hosts=True)
        client.pytis_start_processes(configuration)
        client.connect_session(s_uuid)
        client.clean_sessions(s_uuid)
        client.start_session(s_uuid)
        client.pytis_setup(s_uuid, configuration)
        try:
            while client.session_ok(s_uuid):
                client.pytis_handle_queues()
                time.sleep(0.1)
        except KeyboardInterrupt:
            pass
        client.terminate_session(s_uuid)
           
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--broker-url')
    args = parser.parse_args()
    PytisClient.run(args.broker_url)

# Local Variables:
# time-stamp-pattern: "30/^_VERSION = '%Y-%02m-%02d %02H:%02M'"
# End:
