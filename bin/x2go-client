#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (C) 2011, 2012, 2014 Brailcom, o.p.s.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

# ATTENTION: This should be updated on each code change.
_VERSION = '2014-12-16 18:39'

import argparse
import imp
import multiprocessing
import os
import platform
import re
import subprocess
import sys
import time

import paramiko
import rpyc
import x2go

import pytis.remote

def on_windows():
    return platform.system() == 'Windows'

_NONE = object()

class ClientException(Exception):
    pass

class Configuration(object):

    _CONFIGURATION_FILE = 'config.py'
    _RPYC_FILE = 'rpyc'

    def __init__(self):
        self._directory = self._configuration_directory()
        self._configuration = self._read_configuration()

    def _configuration_directory(self):
        basename = '_pytis_x2go' if on_windows() else '.pytis-x2go'
        dirname = os.path.expanduser(os.path.join('~', basename))
        if not os.access(dirname, os.F_OK):
            try:
                os.mkdir(dirname, 0700)
            except Exception as e:
                raise ClientException("Can't create client directory: %s" % (dirname,), e)
        elif not os.access(dirname, os.R_OK | os.W_OK | os.X_OK):
            raise ClientException("Client directory not accessible: %s" % (dirname,))
        return dirname

    def _configuration_file(self, filename):
        return os.path.join(self._configuration_directory(), filename)

    def _read_configuration(self):
        filename = self._configuration_file(self._CONFIGURATION_FILE)
        if not os.access(filename, os.F_OK):
            try:
                open(filename, 'w').close()
            except Exception as e:
                raise ClientException("Can't create client configuration file: %s" % (filename,), e)
        elif not os.access(filename, os.R_OK | os.W_OK):
            raise ClientException("Client configuration not accessible: %s" % (filename,))
        try:
            configuration = imp.load_source('_config', filename)
        except Exception as e:
            raise ClientException("Error when loading client configuration: %s" % (filename,), e)
        return configuration
    
    def get(self, key, type_, default=_NONE):
        args = () if default is _NONE else (default,)
        try:
            value = getattr(self._configuration, key, *args)
        except AttributeError:
            raise ClientException("Configuration parameter not available: %s" % (key,))
        if not isinstance(value, type_) and value != default:
            raise ClientException("Invalid configuration parameter type: %s = %r (is not %s)" %
                                  (key, value, type_,))
        return value

    def set(self, key, value):
        setattr(self._configuration, key, value)

    def rpyc_file(self):
        return self._configuration_file(self._RPYC_FILE)

class RpycInfo(object):

    def __init__(self, configuration, port=None, password=None):
        self._filename = configuration.rpyc_file()
        self._port = port
        self._password = password

    def read(self):
        try:
            f = open(self._filename)
            port = int(f.next().rstrip())
            password = f.next().rstrip()
        except Exception as e:
            raise ClientException("Can't read RPyC info file: %s" % (self._filename,), e)
        self._port = int(port)
        self._password = password

    def store(self):
        try:
            f = open(self._filename, 'w')
            f.write('%s\n%s' % (self._port, self._password,))
            f.close()
        except Exception as e:
            raise ClientException("Error when writing RPyC info file: %s" % (self._filename,), e)
        
    def port(self):
        return self._port

    def password(self):
        return self._password

class PytisClient(x2go.X2GoClient):

    _DEFAULT_RPYC_PORT = 10000
    _MAX_RPYC_PORT_ATTEMPTS = 100

    def __init__(self, *args, **kwargs):
        super(PytisClient, self).__init__(*args, **kwargs)
        self._pytis_port_queue = multiprocessing.Queue()
        self._pytis_password_queue = multiprocessing.Queue()
        self._pytis_terminate = multiprocessing.Value('b', False)
    
    def pytis_setup(self, s_uuid, configuration):
        # Configuration transfer to the server
        session = self.get_session(s_uuid)
        control_session = session.control_session
        # It would be better to use self.info_backend or
        # self.get_session_info(s_uuid) as the source of remote_container
        # (instead of _x2go_remote_home + '/.x2go') and agent_pid (instead of
        # application) but this information is often unavailable here for
        # unclear reasons.
        session_id = self.session_registry(s_uuid).terminal_session.session_info.name
        server_file_name = '%s/.x2go/ssh/pytis.%s' % (control_session._x2go_remote_home,
                                                      session_id,)
        class ServerInfo(object):
            def __init__(self):
                self._port = None
                self._password = None
            def set_port(self, port):
                self._port = port
            def set_password(self, password):
                self._password = password
            def write(self):
                if self._port is None or self._password is None:
                    return
                data = '0:%s:%s:' % (self._port, self._password,)
                control_session._x2go_sftp_write(server_file_name, data)
        self._pytis_server_info = ServerInfo()

    def pytis_handle_queues(self):
        def get(queue):
            value = None
            while not queue.empty():
                value = queue.get()
            return value
        password = get(self._pytis_password_queue)
        port = get(self._pytis_port_queue)
        if password is not None or port is not None:
            info = self._pytis_server_info
            if password is not None:
                info.set_password(password)
            if port is not None:
                info.set_port(port)
            info.write()

    def pytis_start_processes(self, configuration):
        # RPyC server
        import pytis.remote.pytisproc as pytisproc
        rpyc_stop_queue = multiprocessing.Queue()
        rpyc_port = multiprocessing.Value('i', 0)
        ssh_tunnel_alive = multiprocessing.Value('b', False)
        def check_rpyc_server():
            process = None
            while True:
                if self._pytis_terminate.value:
                    if process is not None:
                        process.terminate()
                    sys.exit()
                # Look for a running RPyC instance
                running = True
                rpyc_info = RpycInfo(configuration)
                try:
                    rpyc_info.read()
                except ClientException:
                    running = False
                if running:
                    # Check whether it's our instance
                    # We must be careful here not to send the password to an RPyC instance
                    # of another user.
                    port = rpyc_info.port()
                    password = rpyc_info.password()
                    authenticator = pytisproc.PasswordAuthenticator(password,
                                                                    ssh_tunnel=ssh_tunnel_alive)
                    try:
                        authenticator.connect('localhost', port)
                    except:
                        running = False
                if not rpyc_stop_queue.empty():
                    while not rpyc_stop_queue.empty():
                        rpyc_stop_queue.get()
                    if running and process is not None:
                        process.terminate()
                    running = False
                # If no running RPyC instance was found then start one
                if not running:
                    authenticator = pytisproc.PasswordAuthenticator()
                    default_port = self._DEFAULT_RPYC_PORT
                    port_limit = default_port + self._MAX_RPYC_PORT_ATTEMPTS
                    for port in range(default_port, port_limit):
                        try:
                            server = rpyc.utils.server.ForkingServer(pytisproc.PytisUserService,
                                                                     hostname='localhost',
                                                                     port=port,
                                                                     authenticator=authenticator)
                            break
                        except:
                            pass
                    else:
                        raise ClientException("No free port found for RPyC in the range %s-%s" %
                                              (default_port, port_limit - 1,))
                    server.service.authenticator = authenticator
                    rpyc_port.value = port
                    rpyc_info = RpycInfo(configuration, port=port,
                                         password=authenticator.password())
                    rpyc_info.store()
                    process = multiprocessing.Process(target=server.start)
                    process.start()
                    self._pytis_password_queue.put(rpyc_info.password())
                time.sleep(1)
        multiprocessing.Process(target=check_rpyc_server).start()
        # ssh tunnel
        def check_ssh_tunnel():
            try:
                password = configuration.get('password', basestring)
            except ClientException:
                password = None
            try:
                key_filename = configuration.get('key_filename', basestring)
            except ClientException:
                key_filename = None
            while True:
                while rpyc_port.value == 0:
                    time.sleep(0.1)
                port = multiprocessing.Value('i', 0)
                tunnel = pytis.remote.ReverseTunnel(configuration.get('host', basestring),
                                                    rpyc_port.value, ssh_forward_port=port,
                                                    ssh_user=configuration.get('user', basestring),
                                                    ssh_password=password,
                                                    key_filename=key_filename)
                ssh_tunnel_alive.value = True
                tunnel.start()
                while not port.value and tunnel.is_alive():
                    time.sleep(0.1)
                self._pytis_port_queue.put(port.value)
                while True:
                    if self._pytis_terminate.value:
                        tunnel.terminate()
                        sys.exit()
                    if tunnel.is_alive():
                        time.sleep(1)
                    else:
                        ssh_tunnel_alive.value = False
                        # We must restart RPyC as well in order to prevent password leak
                        rpyc_stop_queue.put(True)
                        break
        multiprocessing.Process(target=check_ssh_tunnel).start()

    def terminate_session(self, *args, **kwargs):
        try:
            return super(PytisClient, self).terminate_session(*args, **kwargs)
        finally:
            self._pytis_terminate.value = True

    @classmethod
    def _pytis_dialog(class_, *args, **kwargs):
        if on_windows():
            zenity = os.path.join(sys.path[0], 'zenity.exe')
        else:
            zenity = 'zenity'
        return class_._pytis_zenity_dialog(zenity, *args, **kwargs)

    @classmethod
    def _pytis_zenity_dialog(class_, zenity, kind, title, options=None, filename=None,
                             ok_label=None, cancel_label=None):
        dialog = [zenity]
        if title:
            dialog.extend(['--text', title])
        if ok_label:
            dialog.extend(['--ok-label', ok_label])
        if cancel_label:
            dialog.extend(['--cancel-label', cancel_label])
        if kind == 'list':
            dialog.extend(['--list', '--column', title])
            dialog.extend(options)
        elif kind == 'password':
            dialog.append('--password')
        elif kind == 'file':
            dialog.append('--file-selection')
            if filename:
                dialog.extend(['--filename', filename])
        elif kind == 'question':
            dialog.extend(['--question', '--text', title])
            if ok_label and cancel_label:
                dialog.append('--default-cancel')
        else:
            raise Exception("Unsupported dialog kind", kind)
        try:
            output = subprocess.check_output(dialog)
        except subprocess.CalledProcessError:
            return None
        return output.rstrip('\r\n')

    @classmethod
    def _pytis_ssh_connect(class_, parameters):
        if not parameters['password']:
            parameters['password'] = 'X'
        methods = []
        client = paramiko.SSHClient()
        client.load_system_host_keys()
        if parameters.get('_add_to_known_hosts'):
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        selected_method = None
        while True:
            connect_parameters = dict([(k, v,) for k, v in parameters.items() if k[0] != '_'])
            try:
                client.connect(**connect_parameters)
                break
            except paramiko.ssh_exception.AuthenticationException as e:
                if selected_method == 'publickey':
                    password = class_._pytis_dialog('password', "Key password")
                    if password is not None:
                        parameters['password'] = password
                        continue
                if not methods:
                    try:
                        methods = client.get_transport().auth_none(parameters['username'])
                    except paramiko.ssh_exception.BadAuthenticationType as e:
                        methods = e.args[1]
                if 'password' in methods:
                    if 'publickey' in methods:
                        answer = class_._pytis_dialog('question', "Default authentication failed",
                                                      ok_label="Login using password",
                                                      cancel_label="Login using a key file")
                        selected_method = 'publickey' if answer is None else 'password'
                    else:
                        selected_method = 'password'
                elif 'publickey' in methods:
                    selected_method = 'publickey'
                else:
                    raise Exception("No supported ssh connection method available")
                parameters['_method'] = selected_method
                if selected_method == 'password':
                    password = class_._pytis_dialog('password', "Login password")
                    if not password:
                        return None
                    parameters['password'] = password
                elif selected_method == 'publickey':
                    ssh_directory = os.path.join(os.path.expanduser('~'), '.ssh', '')
                    key_filename = class_._pytis_dialog('file', "Select ssh key file",
                                                        filename=ssh_directory)
                    if key_filename is None:
                        return None
                    parameters['key_filename'] = key_filename
                else:
                    raise Exception("Program error")
        return client

    @classmethod
    def _pytis_select_broker_session(class_, broker_url, add_to_known_hosts):
        match = re.match(('^(?P<protocol>(ssh|http(|s)))://'
                          '(|(?P<user>[a-zA-Z0-9_\.-]+)'
                          '(|:(?P<password>.*))@)'
                          '(?P<host>[a-zA-Z0-9\.-]+)'
                          '(|:(?P<port>[0-9]+))'
                          '($|/(?P<path>.*)$)'), broker_url)
        if match is None:
            raise Exception("Invalid broker address", broker_url)
        broker_parameters = match.groupdict()
        protocol = broker_parameters['protocol']
        if protocol != 'ssh':
            raise Exception("Unsupported broker protocol", protocol)
        password = broker_parameters.get('password')
        port = int(broker_parameters.get('port') or '22')
        # Fetch session list
        sessions = ''
        text = ''
        configuration = None
        in_config = False
        parameters = dict(hostname=broker_parameters['host'], port=port,
                          username=broker_parameters['user'], password=password,
                          _add_to_known_hosts=add_to_known_hosts,
                          key_filename=os.path.expanduser('~/.ssh/id_rsa'))
        client = class_._pytis_ssh_connect(parameters)
        if client is None:
            return
        command = '/usr/bin/x2gobroker-ssh --task listsessions'
        __stdin, stdout, __stderr = client.exec_command(command)
        while True:
            line = stdout.readline()
            if not line:
                break
            text += line
            if line.strip() == 'START_USER_SESSIONS':
                in_config = True
                continue
            elif line.strip() == 'END_USER_SESSIONS':
                in_config = False
            if in_config:
                sessions += line
        import ConfigParser
        import StringIO
        config = ConfigParser.ConfigParser()
        config.readfp(StringIO.StringIO(sessions))
        # Select session
        sections = config.sections()
        session_name = class_._pytis_dialog('list', "Select session", options=sections)
        if not session_name:
            raise Exception("No session selected.")
        configuration = Configuration()
        for o in config.options(session_name):
            configuration.set(o, config.get(session_name, o))
        # Fetch additional session parameters
        server_regexp = re.compile('^SERVER:(.*):(.*)$')
        text = ''
        command = '/usr/bin/x2gobroker-ssh --task selectsession --sid ' + session_name
        __stdin, stdout, __stderr = client.exec_command(command)
        while True:
            line = stdout.readline()
            if not line:
                break
            text += line
            line = line.strip()
            m = server_regexp.match(line)
            if m is not None:
                host, port = m.groups()
                try:
                    port = int(port)
                except ValueError:
                    raise Exception("Invalid session format", text)
                configuration.set('host', host)
                configuration.set('sshport', port)
        # Finish configuration and return it
        configuration.set('password', parameters['password'])
        configuration.set('key_filename', parameters['key_filename'])
        return configuration
        
    @classmethod
    def run(class_, broker_url=None, add_to_known_hosts=False):
        # Get parameters
        if broker_url:
            configuration = class_._pytis_select_broker_session(broker_url, add_to_known_hosts)
            if configuration is None:
                return
        else:
            configuration = Configuration()
        server = configuration.get('host', basestring)
        port = configuration.get('sshport', int, 22)
        username = configuration.get('user', basestring)
        command = configuration.get('command', basestring)
        try:
            password = configuration.get('password', basestring)
        except ClientException:
            password = None
        try:
            key_filename = configuration.get('key_filename', basestring)
        except ClientException:
            key_filename = None
        parameters = dict(hostname=server, port=port, username=username, password=password,
                          key_filename=key_filename, _add_to_known_hosts=add_to_known_hosts)
        # Check connection parameters and update password
        client = class_._pytis_ssh_connect(parameters)
        if client is None:
            return
        client = None
        password = parameters['password']
        configuration.set('password', password)
        # Run
        client = class_(use_cache=False, loglevel=x2go.log.loglevel_DEBUG)
        s_uuid = client.register_session(server, port=port, username=username,
                                         key_filename=key_filename,
                                         cmd=command, add_to_known_hosts=add_to_known_hosts)
        client.pytis_start_processes(configuration)
        session = client.session_registry(s_uuid)
        session.sshproxy_params['key_filename'] = key_filename
        session.sshproxy_params['look_for_keys'] = False
        client.connect_session(s_uuid, username=username, password=password)
        client.clean_sessions(s_uuid)
        client.start_session(s_uuid)
        client.pytis_setup(s_uuid, configuration)
        try:
            while client.session_ok(s_uuid):
                client.pytis_handle_queues()
                time.sleep(0.1)
        except KeyboardInterrupt:
            pass
        client.terminate_session(s_uuid)
           
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--broker-url')
    parser.add_argument('--add-to-known-hosts', action='store_true')
    args = parser.parse_args()
    PytisClient.run(args.broker_url, args.add_to_known_hosts)

# Local Variables:
# time-stamp-pattern: "30/^_VERSION = '%Y-%02m-%02d %02H:%02M'"
# End:
