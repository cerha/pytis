#title Tipy a triky

Tento dokument shrnuje rùzné technické tipy a problémy týkající se pou¾ívaných
nástrojù, na které jsme nìkdy narazili, a» u¾ známe jejich øe¹ení nebo ne.
Jedná se o jakousi formu HOWTO.


* Python

- Interpret u spustitelných programù je dobré zapisovat ne pøímo natvrdo cestou
  k nìmu, nýbr¾ jako =#!/usr/bin/env python=.  Je to ménì závislé na konkrétní
  instalaci.

- Pokud má modul na top-level úrovni spustit nìjakou hlavní
  funkci (øeknìme =run_it=), je místo pøímého volání funkce lépe ji
  obalit podmínkou:

  <example>
  if __name__ == '__main__':
      run_it ()
  </example>

  Pak se funkce zavolá jen tehdy, je-li modul spu¹tìn, ne pøi ka¾dém
  importu.
  
- Je-li pou¾it soubor s názvem stejným jako má nìjaký top-level modul ze
  standardní distribuce, mohou vzniknout potí¾e.  Pøíkladem je situace, kdy
  v nìjakém modulu existuje soubor øeknìme =types.py= a libovolný soubor
  v tém¾e adresáøi importuje standardní modul (øeknìme =traceback=), který
  importuje standardní modul =types=.  Pak =traceback= místo standardního
  =types= naimportuje na¹e =types.py=.

  Dìje se tak pravdìpodobnì z toho dùvodu, ¾e Python pøi importu modulu
  z nìjakého adresáøe pøidává tento adresáø na zaèátek =sys.path=.  Dle mého
  názoru se jedná nedostatek Pythonu, který neumím rozumnì obejít.  Problém je
  nepøíjemný zejména proto, ¾e nemù¾eme pøedejít kolizi s budoucí distribucí.

  Pokud ji¾ konflikt vznikne, lze jej èásteènì øe¹it pøejmenováním souboru na
  verzi s podtr¾ítekm a umístìním pøíkazu =import types_ as types= do
  =__init__.py= daného adresáøe.  Soubor pak lze importovat takto:

  <example>
  import adresar
  ...
  foo = adresar.types.neco
  ...
  </example>

- Je tøeba dbát opatrnosti pøi pou¾ívání mutable objektù coby implicitních
  hodnot nepovinných parametrù funkcí.  Implicitní hodnoty jsou inicializovány
  *pouze jednou*, ne pøi ka¾dém volání funkce.

  Pøíklad:

  <example>
  def foo(x=[]):
      x.append('mark')
      print x
  foo()
  foo()
  </example>

  Druhé volání =foo= vypí¹e =['mark', 'mark']= a nikoliv =['mark']=, jak by
  nìkdo mohl intuitivnì oèekávat.  Lépe je tedy funkci =foo= definovat takto:

  <example>
  def foo(x=[]):
      if x == []:
          x = []
      ...
  </example>

- Statické metody lze v Pythonu 2.2 definovat pomocí nedokumentované funkce
  =classmethod=.  Napøíklad:

  <example>
  class Foo:
      def bar(class_):
          print class_
      bar = classmethod(bar)
  </example>

  Potom lze statickou metodu volat takto:

  <example>
  >>> Foo.bar()
  __builtin__.Foo
  </example>

- Definuje-li se tøída vícenásobnou dìdièností a nìkterý z jejích pøedkù je
  potomkem =object=, pak je ¾ádoucí, aby v¹ichni pøedci byly potomkem =object=.
  Jinak to mù¾e dìlat psí kusy.


** pyunit

Pokud se spustitelný soubor =_test.py= spou¹tí jako normální program, lze mu
na pøíkazové øádce zadat argumenty, kterými mohou být testovací tøídy nebo
metody.  Pokud jsou nìjaké argumenty na pøíkazové øádce uvedeny, unittest
spustí pouze jim odpovídající testy.  Tak se lze vyhnout zdlouhavému
spou¹tìní pøíli¹ mnoha testù najednou.


* PostgreSQL

** Backend na nìjakém SQL pøíkazu vytuhne

   Dùvodù, proè se tak mù¾e stát, je více.  Narazil jsem zatím na
   následující:

   - Dvì databázová spojení si lezou do zelí; jedno visí na nedokonèené
     transakci, zatímco druhé èeká na mo¾nost modifikace dat pod ochranou
     této transakce.  Nad detekcí tohoto problému jsem jednou strávil nìkolik
     hodin, kdy jsem si pøi tvorbì testù neuvìdomil, ¾e v metodì tearDown
     je¹tì není zlikvidována instance datové tabulky dr¾ící své databázové
     spojení a v nìm nedokonèenou transakci.  Test pou¾íval pro tvorbu a
     ru¹ení testovacích dat spojení vlastní, které kolidovalo s transakcí
     "skrytého" spojení datové tabulky.  Velmi (a dlouho) jsem se divil, proè
     mi test tuhne na =drop table=.

   - Chyba v databázovém stroji.  To se pøihodilo u rules vyvolávajících
     modifikaci více tabulek.  Pomohl upgrade na novìj¹í verzi (7.1.2).
